<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PRASCore · PRAS</title><meta name="title" content="PRASCore · PRAS"/><meta property="og:title" content="PRASCore · PRAS"/><meta property="twitter:title" content="PRASCore · PRAS"/><meta name="description" content="Documentation for PRAS."/><meta property="og:description" content="Documentation for PRAS."/><meta property="twitter:description" content="Documentation for PRAS."/><meta property="og:url" content="https://nrel.github.io/PRAS/stable/PRASCore/api/"/><meta property="twitter:url" content="https://nrel.github.io/PRAS/stable/PRASCore/api/"/><link rel="canonical" href="https://nrel.github.io/PRAS/stable/PRASCore/api/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PRAS</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../resourceadequacy/">Resource Adequacy</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../quickstart/">Quick Start</a></li></ul></li><li><span class="tocitem">PRAS Components </span><ul><li><a class="tocitem" href="../../PRAS/sysmodelspec/">System Model Specification</a></li><li><a class="tocitem" href="../../PRAS/simulations/">Simulation Specifications</a></li><li><a class="tocitem" href="../../PRAS/results/">Result Specifications</a></li><li><a class="tocitem" href="../../PRAS/capacitycredit/">Capacity Credit Calculation</a></li></ul></li><li><a class="tocitem" href="../../SystemModel_HDF5_spec/">.pras File Format</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../examples/pras_walkthrough/">PRAS 101 Walkthrough</a></li><li><a class="tocitem" href="../../examples/demand_response_walkthrough/">Demand Response Walkthrough</a></li></ul></li><li><a class="tocitem" href="../../extending/">Extending PRAS</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>PRASCore</a><ul class="internal"><li><a class="tocitem" href="#Systems"><span>Systems</span></a></li><li><a class="tocitem" href="#Simulations"><span>Simulations</span></a></li><li><a class="tocitem" href="#Results"><span>Results</span></a></li></ul></li><li><a class="tocitem" href="../../PRASFiles/api/">PRASFiles</a></li><li><a class="tocitem" href="../../PRASCapacityCredits/api/">PRASCapacityCredits</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>PRASCore</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PRASCore</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL/PRAS" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL/PRAS/blob/main/docs/src/PRASCore/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PRASCore-API-reference"><a class="docs-heading-anchor" href="#PRASCore-API-reference">PRASCore API reference</a><a id="PRASCore-API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#PRASCore-API-reference" title="Permalink"></a></h1><h2 id="Systems"><a class="docs-heading-anchor" href="#Systems">Systems</a><a id="Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.SystemModel" href="#PRASCore.Systems.SystemModel"><code>PRASCore.Systems.SystemModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SystemModel{N, L, T&lt;:Period, P&lt;:PowerUnit, E&lt;:EnergyUnit}</code></pre><p>A SystemModel struct contains a representation of a power system to be studied with PRAS. See <a href="../../PRAS/sysmodelspec/#system_specification">system specifications</a> for more  details on components of a system model.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Number of timesteps in the system model</li><li><code>L</code>: Length of each timestep in T units </li><li><code>T</code>: Time period type (e.g., <code>Hour</code>, <code>Minute</code>)</li><li><code>P</code>: Power unit type (e.g., <code>MW</code>, <code>GW</code>)</li><li><code>E</code>: Energy unit type (e.g., <code>MWh</code>, <code>GWh</code>)</li></ul><p><strong>Fields</strong></p><ul><li><code>regions</code>: Representation of system regions (Type - <a href="../../PRAS/sysmodelspec/#Regions">Regions</a>)</li><li><code>interfaces</code>: Information about connections between regions (Type - <a href="../../PRAS/sysmodelspec/#Interfaces">Interfaces</a>)</li><li><code>generators</code>: Collection of system generators (Type - <a href="../../PRAS/sysmodelspec/#Generators">Generators</a>)</li><li><code>region_gen_idxs</code>: Mapping of generators to their respective regions</li><li><code>storages</code>: Collection of system storages (Type - <a href="../../PRAS/sysmodelspec/#Storages">Storages</a>)</li><li><code>region_stor_idxs</code>: Mapping of storage resources to their respective regions</li><li><code>generatorstorages</code>: Collection of system generation-storages (Type - <a href="#PRASCore.Systems.GeneratorStorages">GeneratorStorages</a>)</li><li><code>region_genstor_idxs</code>: Mapping of hybrid resources to their respective regions</li><li><code>lines</code>: Collection of transmission lines connecting regions (Type - <a href="../../PRAS/sysmodelspec/#Lines">Lines</a>)</li><li><code>interface_line_idxs</code>: Mapping of transmission lines to interfaces</li><li><code>timestamps</code>: Time range for the simulation period</li><li><code>attrs</code>: Dictionary of system metadata and attributes</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SystemModel(regions, interfaces, generators, region_gen_idxs, storages, region_stor_idxs,
            generatorstorages, region_genstor_idxs, lines, interface_line_idxs,
            timestamps, [attrs])</code></pre><p>Create a system model with all components specified.</p><pre><code class="language-julia hljs">SystemModel(generators, storages, generatorstorages, timestamps, load, [attrs])</code></pre><p>Create a single-node system model with specified generators, storage, and load profile.</p><pre><code class="language-julia hljs">SystemModel(regions, interfaces, generators, region_gen_idxs, storages, region_stor_idxs,
            generatorstorages, region_genstor_idxs, lines, interface_line_idxs,
            timestamps::StepRange{DateTime}, [attrs])</code></pre><p>Create a system model with <code>DateTime</code> timestamps (will be converted to UTC time zone).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Systems/SystemModel.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.Regions" href="#PRASCore.Systems.Regions"><code>PRASCore.Systems.Regions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Regions{N,P&lt;:PowerUnit}</code></pre><p>A struct representing regions within a power system.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Number of timesteps in the system model</li><li><code>P</code>: The power unit used for demand measurements, subtype of <code>PowerUnit</code></li></ul><p><strong>Fields</strong></p><ul><li><code>names</code>: Name of region (unique)</li><li><code>load</code>: Aggregated electricity demand in each region for each timeperiod, in <code>power_units</code> (<code>P</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Systems/collections.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.Generators" href="#PRASCore.Systems.Generators"><code>PRASCore.Systems.Generators</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Generators{N,L,T&lt;:Period,P&lt;:PowerUnit}</code></pre><p>A struct representing generating assets within a power system.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Number of timesteps in the system model</li><li><code>L</code>: Length of each timestep in T units </li><li><code>T</code>: The time period type used for temporal representation, subtype of <code>Period</code></li><li><code>P</code>: The power unit used for capacity measurements, subtype of <code>PowerUnit</code></li></ul><p><strong>Fields</strong></p><ul><li><code>names</code>: Name of generator</li><li><code>categories</code>: Category of generator</li><li><code>capacity</code>: Maximum available generation capacity in each timeperiod, expressed  in units given by the <code>power_units</code> (<code>P</code>) type parameter</li><li><code>λ</code> (failure probability): probability the generator transitions from  operational to forced outage during a given simulation timestep (unitless)</li><li><code>μ</code> (repair probability): probability the generator transitions from forced  outage to operational during a given simulation timestep (unitless)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Systems/assets.jl#L40-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.Storages" href="#PRASCore.Systems.Storages"><code>PRASCore.Systems.Storages</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Storages{N,L,T&lt;:Period,P&lt;:PowerUnit,E&lt;:EnergyUnit}</code></pre><p>A struct representing storage devices in the system.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Number of timesteps in the system model</li><li><code>L</code>: Length of each timestep in T units</li><li><code>T</code>: The time period type used for temporal representation, subtype of <code>Period</code></li><li><code>P</code>: The power unit used for capacity measurements, subtype of <code>PowerUnit</code></li><li><code>E</code>: The energy unit used for energy storage, subtype of <code>EnergyUnit</code></li></ul><p><strong>Fields</strong></p><ul><li><code>names</code>: Name of storage device</li><li><code>categories</code>: Category of storage device</li><li><code>charge_capacity</code>: Maximum available charging capacity for each storage unit in each timeperiod, expressed in units given by the <code>power_units</code> (<code>P</code>) type parameter</li><li><code>discharge_capacity</code>: Maximum available discharging capacity for each storage unit in each timeperiod, expressed in units given by the <code>power_units</code> (<code>P</code>) type parameter</li><li><code>energy_capacity</code>: Maximum available energy storage capacity for each storage unit in each timeperiod, expressed in units given by the <code>energy_units</code> (<code>E</code>) type parameter</li><li><code>charge_efficiency</code>: Ratio of power injected into the storage device&#39;s reservoir to power withdrawn from the grid, for each storage unit in each timeperiod. Unitless.</li><li><code>discharge_efficiency</code>: Ratio of power injected into the grid to power withdrawn from the storage device&#39;s reservoir, for each storage unit in each timeperiod. Unitless.</li><li><code>carryover_efficiency</code>: Ratio of energy available in the storage device&#39;s reservoir at the beginning of one period to energy retained at the end of the previous period, for each storage unit in each timeperiod. Unitless.</li><li><code>λ</code> (failure probability): Probability the unit transitions from operational to forced outage during a given simulation timestep, for each storage unit in each timeperiod. Unitless.</li><li><code>μ</code> (repair probability): Probability the unit transitions from forced outage to operational during a given simulation timestep, for each storage unit in each timeperiod. Unitless.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Systems/assets.jl#L147-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.GeneratorStorages" href="#PRASCore.Systems.GeneratorStorages"><code>PRASCore.Systems.GeneratorStorages</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorStorages{N,L,T&lt;:Period,P&lt;:PowerUnit,E&lt;:EnergyUnit}</code></pre><p>A struct representing generator-storage hybrid devices within a power system.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Number of timesteps in the system model</li><li><code>L</code>: Length of each timestep in T units</li><li><code>T</code>: The time period type used for temporal representation, subtype of <code>Period</code></li><li><code>P</code>: The power unit used for capacity measurements, subtype of <code>PowerUnit</code></li><li><code>E</code>: The energy unit used for energy storage, subtype of <code>EnergyUnit</code></li></ul><p><strong>Fields</strong></p><ul><li><code>names</code>: Name of generator-storage unit</li><li><code>categories</code>: Category of generator-storage unit</li><li><code>charge_capacity</code>: Maximum available charging capacity for each generator-storage unit in each timeperiod, in <code>power_units</code> (<code>P</code>)</li><li><code>discharge_capacity</code>: Maximum available discharging capacity for each generator-storage unit in each timeperiod, in <code>power_units</code> (<code>P</code>)</li><li><code>energy_capacity</code>: Maximum available energy storage capacity for each generator-storage unit in each timeperiod, in <code>energy_units</code> (<code>E</code>)</li><li><code>charge_efficiency</code>: Ratio of power injected into the device&#39;s reservoir to power withdrawn from the grid, for each generator-storage unit in each timeperiod. Unitless.</li><li><code>discharge_efficiency</code>: Ratio of power injected into the grid to power withdrawn from the device&#39;s reservoir, for each generator-storage unit in each timeperiod. Unitless.</li><li><code>carryover_efficiency</code>: Ratio of energy available in the device&#39;s reservoir at the beginning of one period to energy retained at the end of the previous period, for each generator-storage unit in each timeperiod. Unitless.</li><li><code>inflow</code>: Exogenous power inflow available to each generator-storage unit in each timeperiod, in <code>power_units</code> (<code>P</code>)</li><li><code>gridwithdrawal_capacity</code>: Maximum available capacity to withdraw power from the grid for each generator-storage unit in each timeperiod, in <code>power_units</code> (<code>P</code>)</li><li><code>gridinjection_capacity</code>: Maximum available capacity to inject power to the grid for each generator-storage unit in each timeperiod, in <code>power_units</code> (<code>P</code>)</li><li><code>λ</code> (failure probability): Probability the unit transitions from operational to forced outage during a given simulation timestep, for each generator-storage unit in each timeperiod. Unitless.</li><li><code>μ</code> (repair probability): Probability the unit transitions from forced outage to operational during a given simulation timestep, for each generator-storage unit in each timeperiod. Unitless.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Systems/assets.jl#L314-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.DemandResponses" href="#PRASCore.Systems.DemandResponses"><code>PRASCore.Systems.DemandResponses</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DemandResponses{N,L,T&lt;:Period,P&lt;:PowerUnit,E&lt;:EnergyUnit}</code></pre><p>A struct representing demand response devices in the system.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Number of timesteps in the system model</li><li><code>L</code>: Length of each timestep in T units</li><li><code>T</code>: The time period type used for temporal representation, subtype of <code>Period</code></li><li><code>P</code>: The power unit used for capacity measurements, subtype of <code>PowerUnit</code></li><li><code>E</code>: The energy unit used for energy storage, subtype of <code>EnergyUnit</code></li></ul><p><strong>Fields</strong></p><ul><li><code>names</code>: Name of demand response device</li><li><code>categories</code>: Category of demand response device</li><li><code>borrow_capacity</code>: Maximum available borrowing capacity for each demand response unit in each timeperiod, expressed in units given by the <code>power_units</code> (<code>P</code>) type parameter</li><li><code>payback_capacity</code>: Maximum available payback capacity for each demand response unit in each timeperiod, expressed in units given by the <code>power_units</code> (<code>P</code>) type parameter</li><li><code>energy_capacity</code>: Maximum available energy capable of being held for each demand response unit in each timeperiod, expressed in units given by the <code>energy_units</code> (<code>E</code>) type parameter</li><li><code>borrowed_energy_interest</code>: Growth or decay rate of borrowed energy in the demand response device from the beginning of one period to energy retained at the end of the previous period, for each demand response unit in each timeperiod. A <code>borrowed_energy_interest</code> of 0.0 has no growth or decay. Unitless.</li><li><code>allowable_payback_period</code>: Maximum number of time steps a demand response device can hold borrowed load.  Any energy still contained at the end of the period will be counted as unserved load for that hour.  If borrowed load is paid back before the end of the <code>allowable_payback_period</code>, counter is reset upn further use. (<code>T</code>) type parameter</li><li><code>λ</code> (failure probability): Probability the unit transitions from operational to forced outage during a given simulation timestep, for each storage unit in each timeperiod. Unitless.</li><li><code>μ</code> (repair probability): Probability the unit transitions from forced outage to operational during a given simulation timestep, for each storage unit in each timeperiod. Unitless.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Systems/assets.jl#L521-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.Lines" href="#PRASCore.Systems.Lines"><code>PRASCore.Systems.Lines</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lines{N,L,T&lt;:Period,P&lt;:PowerUnit}</code></pre><p>A struct representing individual transmission lines between regions in a power system.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Number of timesteps in the system model</li><li><code>L</code>: Length of each timestep in T units</li><li><code>T</code>: The time period type used for temporal representation, subtype of <code>Period</code></li><li><code>P</code>: The power unit used for capacity measurements, subtype of <code>PowerUnit</code></li></ul><p><strong>Fields</strong></p><ul><li><code>names</code>: Name of line</li><li><code>categories</code>: Category of line</li><li><code>forward_capacity</code>: Maximum available power transfer capacity from <code>region_from</code> to <code>region_to</code> along the line, for each line in each timeperiod, in <code>power_units</code> (<code>P</code>)</li><li><code>backward_capacity</code>: Maximum available power transfer capacity from <code>region_to</code> to <code>region_from</code> along the line, for each line in each timeperiod, in <code>power_units</code> (<code>P</code>)</li><li><code>λ</code> (failure probability): Probability the line transitions from operational to forced outage during a given simulation timestep, for each line in each timeperiod. Unitless.</li><li><code>μ</code> (repair probability): Probability the line transitions from forced outage to operational during a given simulation timestep, for each line in each timeperiod. Unitless.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Systems/assets.jl#L721-L745">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Systems.Interfaces" href="#PRASCore.Systems.Interfaces"><code>PRASCore.Systems.Interfaces</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Interfaces{N,P&lt;:PowerUnit}</code></pre><p>A struct representing transmission interfaces between regions in a power system.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Number of timesteps in the system model</li><li><code>P</code>: The power unit used for interface limits, subtype of <code>PowerUnit</code></li></ul><p><strong>Fields</strong></p><ul><li><code>regions_from</code>: Index of the first region connected by the interface</li><li><code>regions_to</code>: Index of the second region connected by the interface</li><li><code>limit_forward</code>: Maximum possible total power transfer from <code>regions_from</code> to <code>regions_to</code>, for each interface in each timeperiod, in <code>power_units</code> (<code>P</code>)</li><li><code>limit_backward</code>: Maximum possible total power transfer from <code>regions_to</code> to <code>regions_from</code>, for each interface in each timeperiod, in <code>power_units</code> (<code>P</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Systems/collections.jl#L46-L62">source</a></section></article><h2 id="Simulations"><a class="docs-heading-anchor" href="#Simulations">Simulations</a><a id="Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Simulations.assess-Tuple{SystemModel, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}" href="#PRASCore.Simulations.assess-Tuple{SystemModel, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}"><code>PRASCore.Simulations.assess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assess(system::SystemModel, method::SequentialMonteCarlo, resultspecs::ResultSpec...)</code></pre><p>Run a Sequential Monte Carlo simulation on a <code>system</code> using the <code>method</code> data and return <code>resultspecs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>system::SystemModel</code>: PRAS data structure</li><li><code>method::SequentialMonteCarlo</code>: method for PRAS analysis</li><li><code>resultspecs::ResultSpec...</code>: PRAS metric for metrics like <a href="#PRASCore.Results.Shortfall"><code>Shortfall</code></a> missing generation</li></ul><p><strong>Returns</strong></p><ul><li><code>results::Tuple{Vararg{ResultAccumulator{SequentialMonteCarlo}}}</code>: PRAS metric results</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Simulations/Simulations.jl#L68-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Simulations.DispatchProblem" href="#PRASCore.Simulations.DispatchProblem"><code>PRASCore.Simulations.DispatchProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DispatchProblem(sys::SystemModel)</code></pre><p>Create a min-cost flow problem for the multi-region max power delivery problem with generation and storage discharging in decreasing order of priority, storage charging with excess capacity and demand response devices enabling load shed and shift functionality. Storage, GeneratorStorage, and Demand Response devices within a region are represented individually on the network.</p><p>This involves injections/withdrawals at one node (regional capacity surplus/shortfall) for each modelled region, as well as two/three nodes associated with each Storage/GeneratorStorage device, and a supplementary &quot;slack&quot; node in the network that can absorb undispatched power or pass unserved energy or unused charging capability through to satisfy power balance constraints. Demand Response devices are represented in a structurally similar manner as storage charging and discharging.</p><p>Flows from the generation nodes are free, while flows to charging and from discharging nodes are costed or rewarded according to the time-to-discharge of the storage device, ensuring efficient coordination across units, while enforcing that storage is only discharged once generation capacity is exhausted (implying an operational strategy that prioritizes resource adequacy over economic arbitrage). This is based on the storage dispatch strategy of Evans, Tindemans, and Angeli, as outlined in &quot;Minimizing Unserved Energy Using Heterogenous Storage Units&quot; (IEEE Transactions on Power Systems, 2019). Demand Response devices will borrow energy in devices with the  longest payback window first, and vice versa for payback energy.  Demand Response devices are utilized only after discharging all storage/genstor and paid back before storage/genstor charging.</p><p>Flows to the charging node have an attenuated negative cost (reward), incentivizing immediate storage charging if generation and transmission allows it, while avoiding charging by discharging other storage (since that would incur an overall positive cost).</p><p>Flows to the slack node (representing unused generation or storage discharge capacity) are free, but flows from the slack node to serve load incur the lost load penalty of 9999. Flows from the slack node in lieu of storage charging or discharging are free.</p><p>Flows on transmission interfaces assume a hurdle rate of 1 to keep unserved energy close to the source of the shortage and eliminate loop flows. This has the side-effect of disincentivising wheeling power across multiple regions for charging purposes, however.</p><p>Nodes in the problem are ordered as:</p><ol><li>Regions generation surplus/shortfall (Regions order)</li><li>Storage discharge capacity (Storage order)</li><li>Storage charge capacity (Storage order)</li><li>GenerationStorage inflow capacity (GeneratorStorage order)</li><li>GenerationStorage discharge capacity (GeneratorStorage order)</li><li>GenerationStorage grid injection (GeneratorStorage order)</li><li>GenerationStorage charge capacity (GeneratorStorage order)</li><li>DemandResponse payback capacity (DemandResponse order)</li><li>DemandResponse borrowing capacity (DemandResponse order)</li><li>Slack node</li></ol><p>Edges are ordered as:</p><ol><li>Regions demand unserved (Regions order)</li><li>Regions generation unused (Regions order)</li><li>Interfaces forward flow (Interfaces order)</li><li>Interfaces reverse flow (Interfaces order)</li><li>Storage discharge to grid (Storage order)</li><li>Storage discharge unused (Storage order)</li><li>Storage charge from grid (Storage order)</li><li>Storage charge unused (Storage order)</li><li>GenerationStorage discharge to grid (GeneratorStorage order)</li><li>GenerationStorage discharge unused (GeneratorStorage order)</li><li>GenerationStorage inflow to grid (GenerationStorage order)</li><li>GenerationStorage total to grid (GeneratorStorage order)</li><li>GenerationStorage charge from grid (GeneratorStorage order)</li><li>GenerationStorage charge from inflow (GeneratorStorage order)</li><li>GenerationStorage charge unused (GeneratorStorage order)</li><li>GenerationStorage inflow unused (GeneratorStorage order)</li><li>DemandResponse payback to grid (DemandResponse order)</li><li>DemandResponse payback unused (DemandResponse order)</li><li>DemandResponse borrowing from grid (DemandResponse order)</li><li>DemandResponse borrowing unused (DemandResponse order)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Simulations/DispatchProblem.jl#L1-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Simulations.SequentialMonteCarlo" href="#PRASCore.Simulations.SequentialMonteCarlo"><code>PRASCore.Simulations.SequentialMonteCarlo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SequentialMonteCarlo(;
    samples::Int=10_000,
    seed::Integer=rand(UInt64),
    verbose::Bool=false,
    threaded::Bool=true
)</code></pre><p>Sequential Monte Carlo simulation parameters for PRAS analysis</p><p>It it recommended that you fix the random seed for reproducibility.</p><p><strong>Arguments</strong></p><ul><li><code>samples::Int=10_000</code>: Number of samples</li><li><code>seed::Integer=rand(UInt64)</code>: Random seed</li><li><code>verbose::Bool=false</code>: Print progress</li><li><code>threaded::Bool=true</code>: Use multi-threading</li></ul><p><strong>Returns</strong></p><ul><li><code>SequentialMonteCarlo</code>: PRAS simulation specification</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Simulations/Simulations.jl#L26-L48">source</a></section></article><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.LOLE" href="#PRASCore.Results.LOLE"><code>PRASCore.Results.LOLE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LOLE</code></pre><p><code>LOLE</code> reports loss of load expectation over a particular time period and regional extent. When the reporting period is a single simulation timestep, the metric is equivalent to loss of load probability (LOLP).</p><p>Contains both the estimated value itself as well as the standard error of that estimate, which can be extracted with <code>val</code> and <code>stderror</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/metrics.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.EUE" href="#PRASCore.Results.EUE"><code>PRASCore.Results.EUE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EUE</code></pre><p><code>EUE</code> reports expected unserved energy over a particular time period and regional extent.</p><p>Contains both the estimated value itself as well as the standard error of that estimate, which can be extracted with <code>val</code> and <code>stderror</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/metrics.jl#L106-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.NEUE" href="#PRASCore.Results.NEUE"><code>PRASCore.Results.NEUE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NEUE</code></pre><p><code>NEUE</code> reports normalized expected unserved energy over a regional extent.</p><p>Contains both the estimated value itself as well as the standard error of that estimate, which can be extracted with <code>val</code> and <code>stderror</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/metrics.jl#L138-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.Shortfall" href="#PRASCore.Results.Shortfall"><code>PRASCore.Results.Shortfall</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Shortfall</code></pre><p>The <code>Shortfall</code> result specification reports expectation-based resource adequacy risk metrics such as EUE and LOLE, producing a <code>ShortfallResult</code>.</p><p>A <code>ShortfallResult</code> can be directly indexed by a region name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating  the average unserved energy in that region and timestep. However, in most cases it&#39;s simpler to use <a href="#PRASCore.Results.EUE"><code>EUE</code></a> and <a href="#PRASCore.Results.LOLE"><code>LOLE</code></a> constructors to directly retrieve standard risk metrics.</p><p>Example:</p><pre><code class="language-julia hljs">shortfall, =
    assess(sys, SequentialMonteCarlo(samples=1000), Shortfall())

period = ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)

# Unserved energy mean and standard deviation
sf_mean, sf_std = shortfall[&quot;Region A&quot;, period]

# System-wide risk metrics
eue = EUE(shortfall)
lole = LOLE(shortfall)
neue = NEUE(shorfall)

# Regional risk metrics
regional_eue = EUE(shortfall, &quot;Region A&quot;)
regional_lole = LOLE(shortfall, &quot;Region A&quot;)
regional_neue = NEUE(shortfall, &quot;Region A&quot;)

# Period-specific risk metrics
period_eue = EUE(shortfall, period)
period_lolp = LOLE(shortfall, period)

# Region- and period-specific risk metrics
period_eue = EUE(shortfall, &quot;Region A&quot;, period)
period_lolp = LOLE(shortfall, &quot;Region A&quot;, period)</code></pre><p>See <a href="#PRASCore.Results.ShortfallSamples"><code>ShortfallSamples</code></a> for recording sample-level shortfall results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/Shortfall.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.ShortfallSamples" href="#PRASCore.Results.ShortfallSamples"><code>PRASCore.Results.ShortfallSamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShortfallSamples</code></pre><p>The <code>ShortfallSamples</code> result specification reports sample-level unserved energy outcomes, producing a <code>ShortfallSamplesResult</code>.</p><p>A <code>ShortfallSamplesResult</code> can be directly indexed by a region name and a timestamp to retrieve a vector of sample-level unserved energy results in that region and timestep. <a href="#PRASCore.Results.EUE"><code>EUE</code></a> and <a href="#PRASCore.Results.LOLE"><code>LOLE</code></a> constructors can also be used to retrieve standard risk metrics.</p><p>Example:</p><pre><code class="language-julia hljs">shortfall, =
    assess(sys, SequentialMonteCarlo(samples=10), ShortfallSamples())

period = ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)

samples = shortfall[&quot;Region A&quot;, period]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

# System-wide risk metrics
eue = EUE(shortfall)
lole = LOLE(shortfall)
neue = NEUE(shortfall)

# Regional risk metrics
regional_eue = EUE(shortfall, &quot;Region A&quot;)
regional_lole = LOLE(shortfall, &quot;Region A&quot;)
regional_neue = NEUE(shortfall, &quot;Region A&quot;)

# Period-specific risk metrics
period_eue = EUE(shortfall, period)
period_lolp = LOLE(shortfall, period)

# Region- and period-specific risk metrics
period_eue = EUE(shortfall, &quot;Region A&quot;, period)
period_lolp = LOLE(shortfall, &quot;Region A&quot;, period)</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="../../PRAS/results/#Shortfall"><code>Shortfall</code></a> for average shortfall outcomes when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/ShortfallSamples.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.Surplus" href="#PRASCore.Results.Surplus"><code>PRASCore.Results.Surplus</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Surplus</code></pre><p>The <code>Surplus</code> result specification reports unused generation and storage discharge capability of <code>Regions</code>, producing a <code>SurplusResult</code>.</p><p>A <code>SurplusResult</code> can be indexed by region name and timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average unused capacity in that region and timestep.</p><p>Example:</p><pre><code class="language-julia hljs">surplus, =
    assess(sys, SequentialMonteCarlo(samples=1000), Surplus())

surplus_mean, surplus_std =
    surplus[&quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.SurplusSamples"><code>SurplusSamples</code></a> for sample-level surplus results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/Surplus.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.SurplusSamples" href="#PRASCore.Results.SurplusSamples"><code>PRASCore.Results.SurplusSamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SurplusSamples</code></pre><p>The <code>SurplusSamples</code> result specification reports sample-level unused generation and storage discharge capability of <code>Regions</code>, producing a <code>SurplusSamplesResult</code>.</p><p>A <code>SurplusSamplesResult</code> can be indexed by region name and timestamp to retrieve a vector of sample-level surplus values in that region and timestep.</p><p>Example:</p><pre><code class="language-julia hljs">surplus, =
    assess(sys, SequentialMonteCarlo(samples=10), SurplusSamples())

samples = surplus[&quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="../../PRAS/results/#Surplus"><code>Surplus</code></a> for estimated average surplus values when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/SurplusSamples.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.Flow" href="#PRASCore.Results.Flow"><code>PRASCore.Results.Flow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Flow</code></pre><p>The <code>Flow</code> result specification reports the estimated average flow across transmission <code>Interfaces</code>, producing a <code>FlowResult</code>.</p><p>A <code>FlowResult</code> can be indexed by a directional <code>Pair</code> of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average net flow magnitude and direction relative to the given directed interface in that timestep. For a query of <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code>, if estimated average flow was from A to B, the reported value would be positive, while if average flow was in the reverse direction, from B to A, the value would be negative.</p><p>Example:</p><pre><code class="language-julia hljs">flows, =
    assess(sys, SequentialMonteCarlo(samples=1000), Flow())

flow_mean, flow_std =
    flows[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]
flow2_mean, flow2_std =
    flows[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]
@assert flow_mean == -flow2_mean</code></pre><p>See <a href="#PRASCore.Results.FlowSamples"><code>FlowSamples</code></a> for sample-level flow results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/Flow.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.FlowSamples" href="#PRASCore.Results.FlowSamples"><code>PRASCore.Results.FlowSamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FlowSamples</code></pre><p>The <code>FlowSamples</code> result specification reports the sample-level magnitude and direction of power flows across <code>Interfaces</code>, producing a <code>FlowSamplesResult</code>.</p><p>A <code>FlowSamplesResult</code> can be indexed by a directional <code>Pair</code> of region names and a timestamp to retrieve a vector of sample-level net flow magnitudes and directions relative to the given directed interface in that timestep. For a query of <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code>, if flow in one sample was from A to B, the reported value would be positive, while if flow was in the reverse direction, from B to A, the value would be negative.</p><p>Example:</p><pre><code class="language-julia hljs">flows, =
    assess(sys, SequentialMonteCarlo(samples=10), FlowSamples())

samples = flows[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

samples2 = flows[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples == -samples2</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="../../PRAS/results/#Flow"><code>Flow</code></a> for estimated average flow results when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/FlowSamples.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.Utilization" href="#PRASCore.Results.Utilization"><code>PRASCore.Results.Utilization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Utilization</code></pre><p>The <code>Utilization</code> result specification reports the estimated average absolute utilization of <code>Interfaces</code>, producing a <code>UtilizationResult</code>.</p><p>Whereas <code>Flow</code> reports the average directional power transfer across an interface, <code>Utilization</code> reports the absolute value of flow relative to the interface&#39;s transfer capability (counting the effects of line outages). For example, a symmetrically-constrained interface which is fully congested with max power flowing in one direction in half of the samples, and the other direction in the remaining samples, would have an average flow of 0 MW, but an average utilization of 100%.</p><p>A <code>UtilizationResult</code> can be indexed by a <code>Pair</code> of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average utilization of the interface. Given the absolute value nature of the outcome, results are independent of direction. Querying <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code> will yield the same result as <code>&quot;Region B&quot; =&gt; &quot;Region A&quot;</code>.</p><p>Example:</p><pre><code class="language-julia hljs">utils, =
    assess(sys, SequentialMonteCarlo(samples=1000), Utilization())

util_mean, util_std =
    utils[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

util2_mean, util2_std =
    utils[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert util_mean == util2_mean</code></pre><p>See <a href="#PRASCore.Results.UtilizationSamples"><code>UtilizationSamples</code></a> for sample-level utilization results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/Utilization.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.UtilizationSamples" href="#PRASCore.Results.UtilizationSamples"><code>PRASCore.Results.UtilizationSamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UtilizationSamples</code></pre><p>The <code>UtilizationSamples</code> result specification reports the sample-level absolute utilization of <code>Interfaces</code>, producing a <code>UtilizationSamplesResult</code>.</p><p>Whereas <code>FlowSamples</code> reports the directional power transfer across an interface, <code>UtilizationSamples</code> reports the absolute value of flow relative to the interface&#39;s transfer capability (counting the effects of line outages). For example, a 100 MW symmetrically-constrained interface which is fully congested may have a flow of +100 or -100 MW, but in both cases the utilization will be 100%. If a 50 MW line in the interface went on outage, flow may drop to +50 or -50 MW, but utilization would remain at 100%.</p><p>A <code>UtilizationSamplesResult</code> can be indexed by a <code>Pair</code> of region names and a timestamp to retrieve a vector of sample-level utilizations of the interface in that timestep. Given the absolute value nature of the outcome, results are independent of direction. Querying <code>&quot;Region A&quot; =&gt; &quot;Region B&quot;</code> will yield the same result as <code>&quot;Region B&quot; =&gt; &quot;Region A&quot;</code>.</p><p>Example:</p><pre><code class="language-julia hljs">utils, =
    assess(sys, SequentialMonteCarlo(samples=10), UtilizationSamples())

samples =
    utils[&quot;Region A&quot; =&gt; &quot;Region B&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10

samples2 =
    utils[&quot;Region B&quot; =&gt; &quot;Region A&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples == samples2</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="../../PRAS/results/#Utilization"><code>Utilization</code></a> for sample-averaged utilization results when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/UtilizationSamples.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.GeneratorAvailability" href="#PRASCore.Results.GeneratorAvailability"><code>PRASCore.Results.GeneratorAvailability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorAvailability</code></pre><p>The <code>GeneratorAvailability</code> result specification reports the sample-level discrete availability of <code>Generators</code>, producing a <code>GeneratorAvailabilityResult</code>.</p><p>A <code>GeneratorAvailabilityResult</code> can be indexed by generator name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">genavail, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorAvailability())

samples = genavail[&quot;MyGenerator123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/GeneratorAvailability.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageAvailability" href="#PRASCore.Results.GeneratorStorageAvailability"><code>PRASCore.Results.GeneratorStorageAvailability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageAvailability</code></pre><p>The <code>GeneratorStorageAvailability</code> result specification reports the sample-level discrete availability of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageAvailabilityResult</code>.</p><p>A <code>GeneratorStorageAvailabilityResult</code> can be indexed by generator-storage name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">genstoravail, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageAvailability())

samples = genstoravail[&quot;MyGenerator123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/GeneratorStorageAvailability.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageEnergy" href="#PRASCore.Results.GeneratorStorageEnergy"><code>PRASCore.Results.GeneratorStorageEnergy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageEnergy</code></pre><p>The <code>GeneratorStorageEnergy</code> result specification reports the average state of charge of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageEnergyResult</code>.</p><p>A <code>GeneratorStorageEnergyResult</code> can be indexed by generator-storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given generator-storage device in that timestep.</p><p>Example:</p><pre><code class="language-julia hljs">genstorenergy, =
    assess(sys, SequentialMonteCarlo(samples=1000), GeneratorStorageEnergy())

soc_mean, soc_std =
    genstorenergy[&quot;MyGeneratorStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.GeneratorStorageEnergySamples"><code>GeneratorStorageEnergySamples</code></a> for sample-level generator-storage states of charge.</p><p>See <a href="#PRASCore.Results.StorageEnergy"><code>StorageEnergy</code></a> for average storage states of charge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/GeneratorStorageEnergy.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.GeneratorStorageEnergySamples" href="#PRASCore.Results.GeneratorStorageEnergySamples"><code>PRASCore.Results.GeneratorStorageEnergySamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratorStorageEnergySamples</code></pre><p>The <code>GeneratorStorageEnergySamples</code> result specification reports the sample-level state of charge of <code>GeneratorStorages</code>, producing a <code>GeneratorStorageEnergySamplesResult</code>.</p><p>A <code>GeneratorStorageEnergySamplesResult</code> can be indexed by generator-storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.</p><p>Example:</p><pre><code class="language-julia hljs">genstorenergy, =
    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageEnergySamples())

samples = genstorenergy[&quot;MyGeneratorStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.GeneratorStorageEnergy"><code>GeneratorStorageEnergy</code></a> for estimated average generator-storage state of charge when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/GeneratorStorageEnergySamples.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.StorageAvailability" href="#PRASCore.Results.StorageAvailability"><code>PRASCore.Results.StorageAvailability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StorageAvailability</code></pre><p>The <code>StorageAvailability</code> result specification reports the sample-level discrete availability of <code>Storages</code>, producing a <code>StorageAvailabilityResult</code>.</p><p>A <code>StorageAvailabilityResult</code> can be indexed by storage device name and a timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">storavail, =
    assess(sys, SequentialMonteCarlo(samples=10), StorageAvailability())

samples = storavail[&quot;MyStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/StorageAvailability.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.StorageEnergy" href="#PRASCore.Results.StorageEnergy"><code>PRASCore.Results.StorageEnergy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StorageEnergy</code></pre><p>The <code>StorageEnergy</code> result specification reports the average state of charge of <code>Storages</code>, producing a <code>StorageEnergyResult</code>.</p><p>A <code>StorageEnergyResult</code> can be indexed by storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given storage device in that timestep.</p><p>Example:</p><pre><code class="language-julia hljs">storenergy, =
    assess(sys, SequentialMonteCarlo(samples=1000), StorageEnergy())

soc_mean, soc_std =
    storenergy[&quot;MyStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.StorageEnergySamples"><code>StorageEnergySamples</code></a> for sample-level storage states of charge.</p><p>See <a href="#PRASCore.Results.GeneratorStorageEnergy"><code>GeneratorStorageEnergy</code></a> for average generator-storage states of charge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/StorageEnergy.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.StorageEnergySamples" href="#PRASCore.Results.StorageEnergySamples"><code>PRASCore.Results.StorageEnergySamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StorageEnergySamples</code></pre><p>The <code>StorageEnergySamples</code> result specification reports the sample-level state of charge of <code>Storages</code>, producing a <code>StorageEnergySamplesResult</code>.</p><p>A <code>StorageEnergySamplesResult</code> can be indexed by storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.</p><p>Example:</p><pre><code class="language-julia hljs">storenergy, =
    assess(sys, SequentialMonteCarlo(samples=10), StorageEnergySamples())

samples = storenergy[&quot;MyStorage123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.StorageEnergy"><code>StorageEnergy</code></a> for estimated average storage state of charge when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/StorageEnergySamples.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.DemandResponseAvailability" href="#PRASCore.Results.DemandResponseAvailability"><code>PRASCore.Results.DemandResponseAvailability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DemandResponseAvailability</code></pre><p>The <code>DemandResponseAvailability</code> result specification reports the sample-level discrete availability of <code>DemandResponses</code>, producing a <code>DemandResponseAvailabilityResult</code>.</p><p>A <code>DemandResponseAvailabilityResult</code> can be indexed by demand response device name and a timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">dravail, =
    assess(sys, SequentialMonteCarlo(samples=10), DemandResponseAvailability())

samples = dravail[&quot;MyDR123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/DemandResponseAvailability.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.DemandResponseEnergy" href="#PRASCore.Results.DemandResponseEnergy"><code>PRASCore.Results.DemandResponseEnergy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DemandResponseEnergy</code></pre><p>The <code>DemandResponseEnergy</code> result specification reports the average energy borrowed of <code>DemandResponses</code>, producing a <code>DemandResponseEnergyResult</code>.</p><p>A <code>DemandResponseEnergyResult</code> can be indexed by demand response device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy borrowed level for the given demand response device in that timestep.</p><p>Example:</p><pre><code class="language-julia hljs">drenergy, =
    assess(sys, SequentialMonteCarlo(samples=1000), DemandResponseEnergy())

soc_mean, soc_std =
    drenergy[&quot;MyDemandResponse123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]</code></pre><p>See <a href="#PRASCore.Results.DemandResponseEnergySamples"><code>DemandResponseEnergySamples</code></a> for sample-level demand response states of borrowed energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/DemandResponseEnergy.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.DemandResponseEnergySamples" href="#PRASCore.Results.DemandResponseEnergySamples"><code>PRASCore.Results.DemandResponseEnergySamples</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DemandResponseEnergySamples</code></pre><p>The <code>DemandResponseEnergySamples</code> result specification reports the sample-level state of borrowed energy of <code>DemandResponses</code>, producing a <code>DemandResponseEnergySamplesResult</code>.</p><p>A <code>DemandResponseEnergySamplesResult</code> can be indexed by demand response device name and a timestamp to retrieve a vector of sample-level borrowed energy states for the device in the given timestep.</p><p>Example:</p><pre><code class="language-julia hljs">demandresponseenergy, =
    assess(sys, SequentialMonteCarlo(samples=10), DemandResponseEnergySamples())

samples = demandresponseenergy[&quot;MyDemandResponse123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Float64}
@assert length(samples) == 10</code></pre><p>Note that this result specification requires large amounts of memory for larger sample sizes. See <a href="#PRASCore.Results.DemandResponseEnergy"><code>DemandResponseEnergy</code></a> for estimated average demand response borrowed energy when sample-level granularity isn&#39;t required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/DemandResponseEnergySamples.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PRASCore.Results.LineAvailability" href="#PRASCore.Results.LineAvailability"><code>PRASCore.Results.LineAvailability</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LineAvailability</code></pre><p>The <code>LineAvailability</code> result specification reports the sample-level discrete availability of <code>Lines</code>, producing a <code>LineAvailabilityResult</code>.</p><p>A <code>LineAvailabilityResult</code> can be indexed by line name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with <code>true</code> indicating that the unit is available and <code>false</code> indicating that it&#39;s unavailable.</p><p>Example:</p><pre><code class="language-julia hljs">lineavail, =
    assess(sys, SequentialMonteCarlo(samples=10), LineAvailability())

samples = lineavail[&quot;MyLine123&quot;, ZonedDateTime(2020, 1, 1, 0, tz&quot;UTC&quot;)]

@assert samples isa Vector{Bool}
@assert length(samples) == 10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/PRAS/blob/ab84b5365038fe2b6640141d0a194bb5b15fefe7/PRASCore.jl/src/Results/LineAvailability.jl#L1-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../changelog/">« Changelog</a><a class="docs-footer-nextpage" href="../../PRASFiles/api/">PRASFiles »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 17 October 2025 21:05">Friday 17 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
