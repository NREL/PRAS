var documenterSearchIndex = {"docs":
[{"location":"examples/demand_response_walkthrough/#demand_response_walkthrough","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"","category":"section"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"This is a complete example of adding demand response to a system, using the RTS-GMLC system","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"Load the PRAS package and other tools necessary for analysis","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"using PRAS\nusing Plots\nusing DataFrames\nusing Dates\nusing Measures","category":"page"},{"location":"examples/demand_response_walkthrough/#Add-Demand-Response-to-the-SystemModel","page":"Demand Response Walkthrough","title":"Add Demand Response to the SystemModel","text":"","category":"section"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"For the purposes of this example, we'll just use the built-in RTS-GMLC model. For further information on loading in systems and exploring please see the PRAS walkthrough.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"rts_gmlc_sys = PRAS.rts_gmlc();\nnothing #hide","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"Lets overview the system information and make sure the demand response we are creating is correct unit wise.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"rts_gmlc_sys","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"First, we  define our new demand response component. In accordance with the broader system the component will have a simulation length of 8784 timesteps, hourly interval, and MW/MWh power/energy units. We will then have a single demand response resource of type \"DR_TYPE1\" with a 50 MW borrow and payback capacity, 200 MWh energy capacity, 0% borrowed energy interest, 6 hour allowable payback time periods, 10% outage probability, and 90% recovery probability. The setup below uses the fill function to create matrices with the correct dimensions for each of the parameters, which can be extended to multiple demand response resources by changing the number_of_drs variable and adjusting names and types accordingly.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"(timesteps,periodlen,periodunit,powerunit,energyunit) = get_params(rts_gmlc_sys);\nnumber_of_drs = 1;\nnew_drs = DemandResponses{timesteps,periodlen,periodunit,powerunit,energyunit}(\n    [\"DR1\"],\n    [\"DR_TYPE1\"],\n    fill(50, number_of_drs, timesteps),   # borrow power capacity\n    fill(50, number_of_drs, timesteps),   # payback power capacity\n    fill(200, number_of_drs, timesteps),  # load energy capacity\n    fill(0.0, number_of_drs, timesteps),  # 0% borrowed energy interest\n    fill(6, number_of_drs, timesteps),    # 6 hour allowable payback time periods\n    fill(0.1, number_of_drs, timesteps),  # 10% outage probability\n    fill(0.9, number_of_drs, timesteps),  # 90% recovery probability\n    );\nnothing #hide","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"We will also assign the demand response to region \"2\" of the system.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"dr_region_indices = [1:0,1:1,2:0];\nnothing #hide","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"We also want to increase the load in the system to see the effect of demand response being utilized. We do this by creating a new load matrix that is 25% higher than the original load.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"updated_load = Int.(round.(rts_gmlc_sys.regions.load .* 1.25));\nnothing #hide","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"Lets define our new regions with the updated load.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"new_regions = Regions{timesteps,powerunit}([\"1\",\"2\",\"3\"],updated_load);\nnothing #hide","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"Finally, we create two new system models, one with dr and one without.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"modified_rts_with_dr  = SystemModel(\n    new_regions, rts_gmlc_sys.interfaces,\n    rts_gmlc_sys.generators, rts_gmlc_sys.region_gen_idxs,\n    rts_gmlc_sys.storages, rts_gmlc_sys.region_stor_idxs,\n    rts_gmlc_sys.generatorstorages, rts_gmlc_sys.region_genstor_idxs,\n    new_drs, dr_region_indices,\n    rts_gmlc_sys.lines, rts_gmlc_sys.interface_line_idxs,\n    rts_gmlc_sys.timestamps);\n\nmodified_rts_without_dr  = SystemModel(\n    new_regions, rts_gmlc_sys.interfaces,\n    rts_gmlc_sys.generators, rts_gmlc_sys.region_gen_idxs,\n    rts_gmlc_sys.storages, rts_gmlc_sys.region_stor_idxs,\n    rts_gmlc_sys.generatorstorages, rts_gmlc_sys.region_genstor_idxs,\n    rts_gmlc_sys.lines, rts_gmlc_sys.interface_line_idxs,\n    rts_gmlc_sys.timestamps);\nnothing #hide","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"For validation, we can check that one new demand response device is in the system, and the other system has none.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"println(\"System with DR\\n \",modified_rts_with_dr.demandresponses)\nprintln(\"\\nSystem without DR\\n \",modified_rts_without_dr.demandresponses)","category":"page"},{"location":"examples/demand_response_walkthrough/#Run-a-Sequential-Monte-Carlo-Simulation-with-and-without-Demand-Response","page":"Demand Response Walkthrough","title":"Run a Sequential Monte Carlo Simulation with and without Demand Response","text":"","category":"section"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"We can now run a sequential monte carlo simulation with and without the demand response to see the effect it has on the system. We will query the shortfall attributable to demand response (load that was borrowed and never able to be paid back) and total system shortfall.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"simspec = SequentialMonteCarlo(samples=100, seed=112);\nresultspecs =   (Shortfall(),DemandResponseShortfall(),DemandResponseEnergy());\n\n\nshortfall_with_dr, dr_shortfall_with_dr,dr_energy_with_dr = assess(modified_rts_with_dr, simspec, resultspecs...);\nshortfall_without_dr, dr_shortfall_without_dr,dr_energy_without_dr = assess(modified_rts_without_dr, simspec, resultspecs...);\nnothing #hide","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"Querying the results, we can see that total system shortfall is lower with demand response, across EUE and LOLE metrics.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"println(\"LOLE Shortfall with DR: \", LOLE(shortfall_with_dr))\nprintln(\"LOLE Shortfall without DR: \", LOLE(shortfall_without_dr))\n\nprintln(\"\\nEUE Shortfall with DR: \", EUE(shortfall_with_dr))\nprintln(\"EUE Shortfall without DR: \", EUE(shortfall_without_dr))","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"We can also collect the same reliability metrics with the demand response shortfall, which is the amount of load that was borrowed and never able to be paid back.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"println(\"EUE Demand Response Shortfall: \", EUE(dr_shortfall_with_dr))\nprintln(\"LOLE Demand Response Shortfall: \", LOLE(dr_shortfall_with_dr))","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"This means over the simulation, load borrowed and unable to be paid back was 250MWh plus or minus 30 MWh. Similarly, we have a loss of load expectation from demand response of 2.1 event hours per year.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"Lets plot the borrowed load of the demand response device over the simulation.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"borrowed_load = [x[1] for x in dr_energy_with_dr[\"DR1\",:]];\nplot(rts_gmlc_sys.timestamps, borrowed_load, xlabel=\"Timestamp\", ylabel=\"DR1 Borrowed Load\", title=\"DR1 Borrowed Load vs Time\", label=\"\")","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"We can see that the demand response device was utilized during the summer months, however never borrowing up to its full 200MWh capacity.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"Lets plot the demand response borrowed load across the month and hour of day for greater granularity on when load is being borrowed.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"months = month.(rts_gmlc_sys.timestamps);\nhours = hour.(rts_gmlc_sys.timestamps) .+ 1;\n\nheatmap_matrix = zeros(Float64, 24, 12);\nfor (val, m, h) in zip(borrowed_load, months, hours)\n    heatmap_matrix[h, m] += val;\nend\n\nheatmap(\n    1:12, 0:23, heatmap_matrix;\n    xlabel=\"Month\", ylabel=\"Hour of Day\", title=\"Total DR1 Borrowed Load (MWh)\",\n    xticks=(1:12, [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]),\n    colorbar_title=\"Borrowed Load\", color=cgrad([:white, :red], scale = :linear),\n    left_margin = 5mm, right_margin = 5mm\n)","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"Maximum borrowed load occurs in the late afternoon July month, with a different peaking pattern as greater surplus exists in August, with reduced load constraints.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"We can also back calculate the borrow power and payback power, by calculating timestep to timestep differences. Note, payback power here will not capture any dr attributable shortfall or the impact of borrowed_energy_interest.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"borrow_power = zeros(Float64, timesteps);\npayback_power= zeros(Float64, timesteps);\nborrow_power = max.(0.0, borrowed_load[2:end] .- borrowed_load[1:end-1]);\npayback_power = max.(0.0, borrowed_load[1:end-1] .- borrowed_load[2:end]);\nnothing #hide","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"And then plotting the two heatmaps to identify when key borrowing and payback periods are occuring.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"borrow_heatmap = zeros(Float64, 24, 12)\npayback_heatmap = zeros(Float64, 24, 12)\n\nfor (b, p, m, h) in zip(borrow_power, payback_power, months[2:end], hours[2:end])\n    borrow_heatmap[h, m] += b\n    payback_heatmap[h, m] += p\nend\n\np1 = heatmap(1:12, 0:23, borrow_heatmap; ylabel = \"Hour of Day\", title=\"DR1 Borrow\",\n    xticks=(1:12, [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]),\n    xtickfont=font(7),\n    colorbar_title=\"Borrow (MW)\", color=cgrad([:white, :red]),\n    left_margin = 5mm, right_margin = 3mm);\np2 = heatmap(1:12, 0:23, payback_heatmap; ylabel = \"Hour of Day\", title=\"DR1 Payback\",\n    xticks=(1:12, [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]),\n    xtickfont=font(7),\n    colorbar_title=\"Payback (MW)\", color=cgrad([:white, :blue]),\n    left_margin = 3mm, right_margin = 5mm);\n\nplot(p1, p2; layout=(1,2), size=(1000, 500), link = :all)","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"We can see peak borrowing occurs around 4-6pm, shifting earlier in the following month, with payback, occurring almost immediately after borrowing, peaking around 7-9pm in July.","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"","category":"page"},{"location":"examples/demand_response_walkthrough/","page":"Demand Response Walkthrough","title":"Demand Response Walkthrough","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Contributing-to-PRAS","page":"Contributing to PRAS","title":"Contributing to PRAS","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PRAS","title":"Contributing to PRAS","text":"Thank you for your interest in contributing to the Probabilistic Resource Adequacy Suite (PRAS) project!","category":"page"},{"location":"contributing/#How-to-Contribute","page":"Contributing to PRAS","title":"How to Contribute","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PRAS","title":"Contributing to PRAS","text":"Report Issues: If you find a bug or have a feature request, please open an issue on the GitHub repository.\nSubmit Pull Requests: Contributions are welcome via pull requests. Please ensure your code is well-documented and tested.\nDocumentation: Improvements to documentation are always appreciated. Feel free to suggest edits or add new content.\nCode Style: Follow the existing code style and conventions used in the project.","category":"page"},{"location":"contributing/#Getting-Help","page":"Contributing to PRAS","title":"Getting Help","text":"","category":"section"},{"location":"contributing/","page":"Contributing to PRAS","title":"Contributing to PRAS","text":"If you have questions or need help, please open an issue or start a discussion on GitHub.","category":"page"},{"location":"contributing/","page":"Contributing to PRAS","title":"Contributing to PRAS","text":"We appreciate your contributions to PRAS!","category":"page"},{"location":"PRAS/results/#results","page":"Result Specifications","title":"Result Specifications","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Different analyses require different kinds of results, and different levels of detail within those results. PRAS considers many operational decisions and system states internally, not all of which are relevant outputs for every analysis. When a user invokes PRAS' assess function, one or more \"result specifications\" must be provided in order to indicate the simulation outcomes that are of interest, and the desired level of sample aggregation or unit type (if applicable) for which those results should be reported. In general, sample-level disaggregation should be used with care, as this can require large amounts of memory if simulating with many samples.","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The current version of PRAS includes six built-in result specification families, with additional user-defined specifications possible (see  Custom Result Specifications). These families can be classified into regional results (Shortfall and Surplus), interface results (Flow and Utilization), and unit results (Availability and Energy).","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"When invoking assess in Julia, result specifications are provided as the final arguments to the function call, and a tuple of results are returned in that same order. (Note that a tuple is always returned, even if a single result specification is requested.) An example of requesting three result specifications is:","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"surplus, flow, genavail = assess(\n    sys, SequentialMonteCarlo(), Surplus(), Flow(), GeneratorAvailability())","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Depending on the result specification, a result object may support indexing into it to obtain results for a specific time period, region, interface, or unit. For example, using the results returned above:","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"timestamp = ZonedDateTime(2020, 1, 1, 13, tz\"UTC\")\ngenname = \"Generator 1\"\nregionname = \"Region A\"\ninterface = \"Region A\" => \"Region B\"\n\n# get the sample mean and standard deviation of observed total system\n# surplus capacity at 1pm UTC on January 1, 2020:\nm, sd = surplus[timestamp]\n\n# get the sample mean and standard deviation of observed surplus capacity\n# in Region A at 1pm UTC on January 1, 2020:\nm, sd = surplus[regionname, timestamp]\n\n# get the sample mean and standard deviation of average interface flow\n# between Region A and Region B:\nm, sd = flow[interface]\n\n# get the sample mean and standard deviation of interface flow\n# between Region A and Region B at 1pm UTC on January 1, 2020:\nm, sd = flow[interface, timestamp]\n\n# get the vector of random generator availability states in every sample\n# for Generator 1, at 1pm UTC on January 1, 2020:\nstates = genavail[genname, timestamp]","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Results can be reported in different ways depending on the result specification being used, and not all types of indexing are appropriate for every result specification. For example, it would not make sense to aggregate interface flows across all interfaces in the system, or surplus power (potentially from energy-limited devices) across all time periods.","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The remainder of this chapter provides additional details about the six built-in result specification families in PRAS.","category":"page"},{"location":"PRAS/results/#Regional-Results","page":"Result Specifications","title":"Regional Results","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Shortfall and Surplus result families are defined over regions, and their result objects can all be indexed into by region name. The table below outlines the simulation specifications that members of these families are compatible with, as well as the levels of disaggregation they support.","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Result Specification Units SMC Sample Region Timestep Region + Timestep\nShortfall Energy •  • • •\nShortfallSamples Energy • • • • •\nSurplus Power •   • •\nSurplusSamples Power • •  • •","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Table: Regional result specification characteristics.","category":"page"},{"location":"PRAS/results/#Shortfall","page":"Result Specifications","title":"Shortfall","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Shortfall family of result specifications (Shortfall and ShortfallSamples) reports on unserved energy occuring during simulations. As quantifying unserved energy is the core aspect of resource adequacy analysis, in practice almost every assessment requests a Shortfall-related result. The basic Shortfall specification is most commonly used and reports average shortfall results, while ShortfallSamples provides more detailed results at the level of individual simulations (samples).","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Shortfall result objects can be indexed into by region, timestep, both region and timestep, or neither. Indexing on neither (via result[]) reports the total shortfall across all regions and time periods.","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Shortfall results are unique among the built-in result types in that the raw results can also be converted to specific probabilistic risk metrics (EUE and LOLE). For sampling-based methods, both metric estimates and the standard error of those estimates are provided. For example, after assessing the system, metrics across all regions and the full simulation horizon can be extracted as:","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"shortfall, = assess(sys, SequentialMonteCarlo(), Shortfall())\neue_overall = EUE(shortfall)\nlole_overall = LOLE(shortfall)","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"More specific metrics can be obtained as well:","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"region = \"Region A\"\nperiod = ZonedDateTime(2020, 1, 1, 0, tz\"America/Denver\")\n\neue_period = EUE(shortfall, period)\nlole_region = LOLE(shortfall, region)\neue_region_period = EUE(shortfall, region, period)","category":"page"},{"location":"PRAS/results/#Surplus","page":"Result Specifications","title":"Surplus","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Surplus family of result specifications (Surplus and SurplusSamples) reports on excess grid injection capacity (via generation or discharging) in the system. This can be used to study \"near misses\" where shortfall came close to occuring but did not actually happen. The Surplus specification reports average surplus across samples, while SurplusSamples reports simulation-level observations.","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Surplus capacity is reported in terms of power, and so results are always disaggregated by timestep (indexed either by timestep or both region and timestep).","category":"page"},{"location":"PRAS/results/#Interface-Results","page":"Result Specifications","title":"Interface Results","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Flow and Utilization families of result specifications are defined over interfaces, and their result objects can all be indexed into by a pair of region names (indicating the source and destination regions for power transfer). The table below outlines the simulation specifications that members of these families are compatible with, as well as the levels of disaggregation they support.","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Result Specification Units SMC Sample Interface Timestep Interface + Timestep\nFlow Power •  •  •\nFlowSamples Power • • •  •\nUtilization – •  •  •\nUtilizationSamples – • • •  •","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Table: Interface result specification characteristics.","category":"page"},{"location":"PRAS/results/#Flow","page":"Result Specifications","title":"Flow","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Flow family of result specifications (Flow and FlowSamples) reports the direction and magnitude of power transfer on an interface. This can be used to study which regions are importers vs exporters of energy, either on average or at specific periods in time. The Flow specification reports average flow across all samples, while FlowSamples reports simulation-level observations. Flow results are directional, so the order in which the regions are provided when looking up a result will determine the result's sign. For example:","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"m1, sd1 = flow[\"Region A\" => \"Region B\"]\nm2, sd2 = flow[\"Region B\" => \"Region A\"]\n\nm1 == -m2 # true\nsd1 == sd2 # true","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Flow values are reported in terms of power, and results are always disaggregated by interface. Results that aggregate over time report the average flow over the time span.","category":"page"},{"location":"PRAS/results/#Utilization","page":"Result Specifications","title":"Utilization","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Utilization family of result specifications (Utilization and UtilizationSamples) is similar to the Flow family, but reports the fraction of an interface's available transfer capacity that is used in the direction of flow, instead of the flow power itself. Results can therefore range between 0 and 1. This metric can be useful for studying the impact of line outages and transmission congestion on unserved energy. The Utilization specification reports average flow across all samples, while UtilizationSamples reports simulation-level observations. Unlike Flow, Utilization results are not directional and so will report the same utilization regardless of the flow direction implied by the order of the provided regions:","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"util, = assess(sys, SequentialMonteCarlo(), Utilization())\nutil[\"Region A\" => \"Region B\"] == util[\"Region B\" => \"Region A\"]","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Utilization values are unitless, and results are always disaggregated by interface. Results that aggregate over time report the average utilization over the time span.","category":"page"},{"location":"PRAS/results/#Unit-Results","page":"Result Specifications","title":"Unit Results","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Availability and Energy families of result specifications are defined over individual units, and their result objects can all be indexed into by a unit name and timestep. The table below outlines the simulation specifications that members of these families are compatible with, as well as the levels of disaggregation they support.","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Result Specification Units SMC Sample Unit Timestep Unit + Timestep\nGeneratorAvailability – • •   •\nStorageAvailability – • •   •\nGeneratorStorageAvailability – • •   •\nLineAvailability – • •   •\nStorageEnergy Energy •   • •\nStorageEnergySamples Energy • •  • •\nGeneratorStorageEnergy Energy •   • •\nGeneratorStorageEnergySamples Energy • •  • •","category":"page"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"Table: Unit result specification characteristics.","category":"page"},{"location":"PRAS/results/#Availability","page":"Result Specifications","title":"Availability","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Availability family of result specifications (GeneratorAvailability, StorageAvailability, GeneratorStorageAvailability, and LineAvailability) reports the availability state (available, or unavailable due to an unplanned outage) of individual units in the simulation. The four result specification variants correspond to the four categories of resources: generators, storages, generator-storages, and lines. Availability is reported as a boolean value (with true indicating the unit is available, and false indicating it isn't), and is always disaggregated by unit, timestep, and sample.","category":"page"},{"location":"PRAS/results/#Energy","page":"Result Specifications","title":"Energy","text":"","category":"section"},{"location":"PRAS/results/","page":"Result Specifications","title":"Result Specifications","text":"The Energy family of result specifications (StorageEnergy, StorageEnergySamples, GeneratorStorageEnergy, and GeneratorStorageEnergySamples) reports the energy state-of-charge associated with individual energy-limited resources. Result specification variants are available for selecting the category of energy-limited resource (storage or generator-storage) to report, as well as for requesting sample-level disaggregation. Energy is always disaggregated by timestep and may also be disaggregated by unit (get the state of charge of a single unit) or aggregated across the system (get the sum of states of charge of all storage devices in the system).","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"PRAS is written in the Julia numerical programming language. If you haven't already, your first step should be to install Julia. Instructions are available at julialang.org/downloads.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Once you have Julia installed, PRAS can be installed from the Julia General registry which is installed by default if you have no other registries installed.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"From the main Julia prompt, type ] to enter the package management REPL. The prompt should change from julia> to something like (v1.10) pkg> (your version number may be slightly different). Type (or paste) the following (minus the pkg> prompt) ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add PRAS","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This will automatically install the PRAS Julia module and all of its related dependencies. At this point you can hit Backspace to switch back to the main julia> prompt.","category":"page"},{"location":"PRASCapacityCredits/#PRAS-Capacity-Credits","page":"PRAS Capacity Credits","title":"PRAS Capacity Credits","text":"","category":"section"},{"location":"PRASCapacityCredits/","page":"PRAS Capacity Credits","title":"PRAS Capacity Credits","text":"PRASCapacityCredits.jl provides functionality for calculating capacity credits of different resource types within a power system. This package integrates with PRASCore for resource adequacy analysis and capacity credit calculations.","category":"page"},{"location":"PRASCapacityCredits/","page":"PRAS Capacity Credits","title":"PRAS Capacity Credits","text":"This package includes:","category":"page"},{"location":"PRASCapacityCredits/","page":"PRAS Capacity Credits","title":"PRAS Capacity Credits","text":"Methods for calculating capacity credits using various methodologies\nIntegration with PRASCore system models and results\nAnalysis tools for understanding resource contributions to reliability","category":"page"},{"location":"PRASCapacityCredits/","page":"PRAS Capacity Credits","title":"PRAS Capacity Credits","text":"For detailed information on available methods and types, see the API Reference.","category":"page"},{"location":"PRAS/sysmodelspec/#system_specification","page":"System Model Specification","title":"System Model Specification","text":"","category":"section"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Assessing the resource adequacy of a power system requires a description of the various resources available to that system, as well as its requirements for serving load. In PRAS, this involves representing the system's supply, storage, transmission, and demand characteristics in a specific data format. This information is stored in memory as a SystemModel Julia data structure, and on disk as an HDF5-formatted file with a .pras file extension. Loading the system data from disk to memory is accomplished via the following Julia code:","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"using PRAS\nsys = SystemModel(\"filepath/to/mysystem.pras\")","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"A full technical specification of the .pras storage format is available in the PRAS source code repository. Storing system data in this format ensures that it will remain readable in the future, even if PRAS' in-memory data representation changes. Newer versions of the PRAS package are always able to read .pras files created for older versions.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"An in-memory SystemModel data structure can also be written back to disk:","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"savemodel(sys, \"filepath/to/mynewsystem.pras\")","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"PRAS simulates simplified power system operations over one or more consecutive time periods. The number of time periods to model and the temporal duration of a single time period are specified on a per-system basis, and must be consistent with provided starting and ending timestamps (defined with respect to a specific time zone).","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"When working with multiple years of weather data, a user may wish to create separate system models and perform runs for each year independently, or create a single system model containing the full multi-year dataset. The first approach can be useful for studying inter-annual variability of annual risk metrics using only the built-in methods – while this is also possible with a single multi-year run, it requires some additional post-processing work.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"PRAS represents a power system as one or more regions, each containing zero or more generators, storages,generator-storages, and  demand responses. Interfaces contain lines and allow power transfer between two regions. The table below summarizes the characteristics of the different resource types (generators, storages, generator-storages, and lines), and the remainder of this section provides more details about each resource type and their associated resource collections (regions or interfaces).","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Parameter Generator Storage Generator-Storage Demand Response Line\nAssociated with a(n)... Region Region Region Region Interface\nName • • • • •\nCategory • • • • •\nGeneration Capacity •    \nInflow Capacity   •  \nCharge Capacity  • •  \nDischarge Capacity  • •  \nLoad Borrow Capacity    • \nLoad Payback Capacity    • \nEnergy Capacity  • •  \nBorrowed Load Capacity    • \nCharge Efficiency  • •  \nDischarge Efficiency  • •  \nCarryover Efficiency  • •  \nBorrowed Energy Interest    • \nGrid Injection Capacity   •  \nGrid Withdrawal Capacity   •  \nForward Transfer Capacity     •\nBackward Transfer Capacity     •\nAvailable→Unavailable Transition Probability • • • • •\nUnavailable→Available Transition Probability • • • • •","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Table: PRAS resource parameters. Parameters in italic are fixed values; all others are provided as a time series.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"The system model exploration section in the PRAS walkthrough  example shows different ways to retrieve and visualize information from these assets.","category":"page"},{"location":"PRAS/sysmodelspec/#Regions","page":"System Model Specification","title":"Regions","text":"","category":"section"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"PRAS does not represent the power system's individual electrical buses. Intead, PRAS regions are used to represent a collection of electrical buses that are grouped together for resource adequacy assessment purposes. Power transfer between buses within a single PRAS region is assumed to take place on a \"copper sheet\" with no intraregional transfer limits or line reliability limitations considered.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"In a PRAS system representation, each region is associated with a descriptive name and an aggregate load time series, representing the total real power demand across all buses in the region, for every simulation period defined by the model.","category":"page"},{"location":"PRAS/sysmodelspec/#Generators","page":"System Model Specification","title":"Generators","text":"","category":"section"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Electrical supply resources with no modeled energy constraints (e.g., a thermal generator that can never exhaust its fuel supply) are represented in PRAS as generators. Generators are the simplest supply resource modeled in PRAS. In addition to a descriptive name and category, each generator unit is associated with a time series of maximum generating capacity. This time series can be a simple constant value (e.g., for a thermal plant) or can change in any arbitrary manner (e.g., for a solar PV array). Each generator is associated with a single PRAS region.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"For each period of an operations simulation, each generator takes on one of two possible availability states. If the unit is available, it is capable of injecting power up to its maximum generation capacity (for that time period) in its associated region. If the unit is unavailable (representing some kind of unplanned or forced outage), it is incapable of injecting any power into the system. Between time periods, the unit may randomly transition to the opposite state according to unit-specific state transition probabilities. Like maximum available capacity, these transition probabilities are represented as time series, and so may be different during different time periods.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"<figure>\n<img src=\"../../images/resourceparameters.png\" alt=\"Relations between power and energy parameters for generator, storage, and generator-storage resources.\" style=\"max-width:2000px;  width:100%;\"/>\n<figcaption> Relations between power and energy parameters for generator, storage, generator-storage, and demand response resources</figcaption>\n</figure>","category":"page"},{"location":"PRAS/sysmodelspec/#Storages","page":"System Model Specification","title":"Storages","text":"","category":"section"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Resources that can shift electrical power availability forward in time but do not provide an overall net addition of energy into the system (e.g., a battery) are referred to as storages in PRAS. Like generators, storages are associated with descriptive name and category metadata. Each storage unit has both a charge and discharge capacity time series, representing the device's maximum ability to withdraw power from or inject power into the grid at a given point in time (as with generator capacity, these values may remain constant over the simulation or may vary to reflect external constraints).","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Storage units also have a maximum energy capacity time series, reflecting the maximum amount of dischargeable energy the device can hold at a given point in time (increasing or decreasing this value will change the duration of time for which the device could charge or discharge at maximum power). The storage's state of charge increases with charging and decreases with discharging, and must always remain between zero and the maximum energy capacity in that time period. The energy flow relationships between these capacities are depicted visually in the figure above.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"If a storage device is charged and the maximum energy capacity decreases such that the state of charge exceeds the energy limit, the additional energy is automatically \"spilled\" (the surplus energy is not injected into the grid, but simply vanishes from the system).","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Storage units may incur losses when moving energy into or out of the device (charge and discharge efficiency), or forward in time (carryover efficiency). When charging the unit, the effective increase to the state of charge is determined by multiplying the charging power by the charge efficiency. Similarly, when discharging the unit, the effective decrease to the state of charge is calculated by dividing the discharge power by the discharge efficiency. The available state of charge in the next time period is determined by multiplying the state of charge in the current time period by the carryover efficiency.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Just as with generators, storages may be in available or unavailable states, and move between these states randomly over time, according to provided state transition probabilities. Unavailable storages cannot inject power into or withdraw power from the grid, but they do maintain their energy state of charge during an outage (minus any carryover losses occurring over time).","category":"page"},{"location":"PRAS/sysmodelspec/#Generator-Storages","page":"System Model Specification","title":"Generator-Storages","text":"","category":"section"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Resources that add net new energy into the system but can also move that energy forward in time instead of injecting it immediately (see figure below for examples) are referred to as generator-storages in PRAS. As the name suggests, they combine the characteristics of both generator and storage devices into a single unit.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"As with generator and storage units, generator-storages have associated name and category metadata, and two availability states with random transition probabilities. They have a potentially time-varying maximum inflow capacity (representing potential new energy being added to the system and analogous to the generator's maximum generating capacity) as well as all the power and energy capacity and efficiency parameters associated with storages. They also have separate maximum grid injection and withdrawal capacity time series, reflecting the fact that (for example) they may not be able to discharge their internal storage at full capacity while simultaneously injecting their full exogenous energy inflow to the grid. The energy flow relationships between these capacities are depicted visually in the figure above.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"A generator-storage in the unavailable state can neither charge nor discharge its storage, nor send energy inflow to the grid. Like storage, it does retain its state of charge during outages (subject to carryover losses).","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"<figure>\n<img src=\"../../images/genstorexamples.svg\" alt=\"Example applications of the generator-storage resource type\" style=\"max-width:2000px;  width:100%;\"/>\n<figcaption> Example applications of the generator-storage resource type </figcaption>\n</figure>","category":"page"},{"location":"PRAS/sysmodelspec/#Demand-Responses","page":"System Model Specification","title":"Demand Responses","text":"","category":"section"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Resources that can shift or shed electrical load forward in time but do not provide an overall net addition of energy into the system (e.g., dr event programs) are referred to as demand responses in PRAS. Like storages, demand response components are associated with descriptive name and category metadata. Each demand response unit has both a load borrow and load payback capacity time series, representing the device's maximum ability to borrow load from or payback load into the grid at a given point in time (as with storage capacity, these values may remain constant over the simulation or may vary to reflect external constraints).","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Demand response units also have a maximum load capacity time series, reflecting the maximum amount of borrowed load the device can hold at a given point in time (increasing or decreasing this value will change the duration of time for which the device could borrow or payback at maximum power). The demand response's state of load increases with borrowing and decreases with payback, and must always remain between zero and the maximum load capacity in that time period. The energy flow relationships between these capacities are depicted visually in the energy relation diagram. If the maximum load capacity is less than the previous hour's state, the load borrowed will be counted as unserved energy.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Demand Response Type Description Relevance to PRAS?\nShift Demand response that encourages the movement of energy consumption from times of high demand to times of day when there is a surplus of generation.​ Yes: can be dispatched as part of the PRAS optimization, to move load out of (net) peak periods.​\nShed Loads that can be curtailed to provide peak capacity reduction and support the system in emergency or contingency events with a range in advance notice times.​ Yes: but caution must be used to avoid too frequent load shed and to capture only load that can truly be shed (i.e., not able to be paid back at a later time). Setting the borrowed_energy_interest to -0.99 will drop all effective borrowed load.​\nShape Demand response that reshapes customer load profiles through price response or behavioral campaigns — ‘load-modifying DR’ — with advance notice of months to days.​ Only through pre-processing to load; no original implementation option within the PRAS optimization.\nShimmy Loads that dynamically adjust to alleviate short-run ramps and disturbances on the system at timescales ranging from seconds up to an hour.​ No: the system conditions and ramping are more granular than what is possible in PRAS.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Table: Common demand response categories and what is possible to model in PRAS. Demand Response type categories are taken from Piette, Mary Ann, et al. \"2025 California Demand Response Potential Study.\".","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Demand response units may incur losses or gains forward in time (borrowed energy interest). The available load borrowed in the next time period is calculated by multiplying the borrowed energy interest  by the current load borrowed and adding to the current load borrowed.  The borrowed energy interest may be positive or negative, indicating a growing or shrinking respectively borrowed load hour to hour. Borrowed energy interest may lead to cases where the maximum load capacity of the demand response device is passed. If this occurs, any load above the maximum capacity will be tracked as unserved energy.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Just as with storage, demand responses may be in available or unavailable states, and move between these states randomly over time, according to provided state transition probabilities. Unavailable demand responses cannot pay back load into or withdraw load from the grid, but they do maintain their current borrowed load during an outage (plus or minus any borrowed energy interest occurring over time).","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Demand response devices also have a maximum amount of time that they can hold borrowed energy.  This cutoff, where borrowed load is unable to be repaid and transitions over to unserved_energy, is refereed to as the allowable payback period. This parameter can be time varying, and therefore enable unique tailoring to the real world device being modeled. The allowable payback window is a integer and follows the timestep units set for the system. If any surplus exists in the region, the demand response device will attempt to payback any borrowed load, before charging storage. If the demand response device pays back all borrowed load before the end of the period, the counter is reset upon further use.","category":"page"},{"location":"PRAS/sysmodelspec/#Interfaces","page":"System Model Specification","title":"Interfaces","text":"","category":"section"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Interfaces define a potential capability to directly exchange power between two regions. Any set of two regions can have at most one interface connecting them. Each interface has both a \"forward\" and \"backward\" time-varying maximum transfer capability: the maximum \"forward\" transfer capability refers to the largest amount of total net power that can be moved from the first region to the second at a given point of time. Similarly, the maximum \"backward\" transfer capability refers to the largest amount of total net power that can be moved from the second region to the first.","category":"page"},{"location":"PRAS/sysmodelspec/#Lines","page":"System Model Specification","title":"Lines","text":"","category":"section"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"Individual lines are assigned to a single specific interface and enable moving power between the two regions defined by that interface. Like other resources, a line is associated with name and category metadata, and transitions randomly between two availability states according to potentially time-varying transition probabilities. Like interfaces, lines have a potentially time-varying \"forward\" and \"backward\" transfer capability, where the forward and backward directions match those associated with the line's interface.","category":"page"},{"location":"PRAS/sysmodelspec/","page":"System Model Specification","title":"System Model Specification","text":"The total interregional transfer capability of an interface in a given direction is the lower of either the sum of transfer limits of available lines in that interface, or the interface-level transfer limit. A line in the unavailable state cannot move power between regions, and so does not contribute to the corresponding interface's sum of line-level transfer limits.","category":"page"},{"location":"PRAS/acknowledgements/#Acknowledgments","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"PRAS/acknowledgements/","page":"Acknowledgments","title":"Acknowledgments","text":"Special thanks to NREL's Trieu Mai, Paul Denholm, and Greg Brinkman for their support and feedback in preparing this work, and to Sarah Awara and Sinnott Murphy (NREL), as well as Armando Figueroa Acevedo (Black & Veatch), for reviewing drafts of this report. Additional thanks go to Jaquelin Cochran, Bethany Frew, Wesley Cole, and Aaron Bloom for their broad historical support in the development of the PRAS model.","category":"page"},{"location":"PRAS/capacitycredit/#capacitycredit","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"","category":"section"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Resource adequacy paradigms premised on adding resource capacities together to meet a planning reserve margin require the quantification of a \"capacity credit\" (sometimes called \"capacity value\") for individual resources. While the process of assigning capacity credits is relatively straightforward for thermal generating units with consistent potential contributions to system adequacy throughout the day and year (assuming no fuel constraints), the contributions of variable and energy-limited resources can be much more difficult to represent as a single capacity rating.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"In these cases, an accurate characterization depends on the broader system context in which the resource operates. Probabilistically derived capacity credit calculations provide a technology-agnostic means of expressing the contributions of different resources (with diverse and potentially complicated operating characteristics and constraints) in terms of a common, simple measure of capacity.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"PRAS provides two different methods for mapping incremental resource adequacy contributions to generic capacity: Equivalent Firm Capacity (EFC) and Effective Load Carrying Capability (ELCC). In each case, the user must provide PRAS with two system representations: one that contains the study resource (the augmented system), and one that does not (the base system). The difference between the two systems is then quantified in terms of a capacity credit.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"By choosing what is included in the base case relative to the augmented case, the user can study either the average, portfolio-level capacity credit of a resource class (by excluding all resources of that class from the base case, and including them all in the augmented case) or the marginal capacity credit (by including almost all of the resource type in the base case, and adding a single incremental unit in the augmented case).","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Note that probabilistically derived capacity credit calculations always involve some kind of measurement of the reduction in system risk associated with moving from the base system to the augmented system. If the base system's risk cannot be reduced (perhaps because the base system's shortfall risk is too small to obtain a non-zero estimate, or because shortfall only occurs in load pockets elsewhere in the system), adequacy-based capacity credit metrics may not be meaningful. In these cases, the starting system may need to be modified, or a different capacity credit calculation method may be required.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"The remainder of this chapter provides details on the theoretical and practical aspects of using EFC and ELCC for capacity credit analysis in PRAS. Further mathematical details regarding capacity credit are available in Zachary and Dent (2011).","category":"page"},{"location":"PRAS/capacitycredit/#Equivalent-Firm-Capacity-(EFC)","page":"Capacity Credit Calculation","title":"Equivalent Firm Capacity (EFC)","text":"","category":"section"},{"location":"PRAS/capacitycredit/#Theory","page":"Capacity Credit Calculation","title":"Theory","text":"","category":"section"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"EFC calculates the amount of idealized \"firm\" capacity (uniformly available across all periods, without ever going on outage) that is required to reproduce the observed resource adequacy benefit (reduction of a specific risk metric) associated with some study resource of interest. It requires both a base case system (without the study resource added) and an augmented system (with the study resource added). The analysis then proceeds as follows:","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Assess the shortfall risk of the base system according to the chosen metric (EUE or LOLE).\nAssess the (lower) shortfall risk of the augmented system according to the chosen metric.\nReassess the shortfall risk of the base system after adding some amount of \"firm\" capacity. If the risk matches that of the augmented system, stop. The amount of firm capacity added is the Equivalent Firm Capacity of the study resource.\nIf the base+firm and augmented system risks do not match, change the amount of firm capacity added to the base system, repeating until the chosen shortfall risk metrics for each system match.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Typically, the counterfactual firm capacity is added to the system as a direct replacement for the study resource, and so is located in the same region (or distributed across multiple regions in corresponding proportions) as the study resource. PRAS uses a bisection method to find the appropriate total firm capacity to add to the base system.","category":"page"},{"location":"PRAS/capacitycredit/#Usage","page":"Capacity Credit Calculation","title":"Usage","text":"","category":"section"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Performing an EFC assessment in PRAS requires specifying two different SystemModels: one representing the base system, and a second representing the augmented system. It also requires specifying the probabilistic risk metric to use when comparing system risks, an upper bound on the EFC (usually, the nameplate capacity of the study resource) and to which region(s) the counterfactual firm capacity should be added. Finally, the simulation specification should be provided (any simulation method can be used).","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"For example, to calculate EFC based on EUE for a resource in region A, with an upper EFC bound of 1000 MW (assuming the SystemModels are represented in MW), using the sequential Monte Carlo simulation specification:","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"assess(base_system, augmented_system,\n       EFC{EUE}(1000, \"A\"), SequentialMonteCarlo())","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"If the study resources are spread over multiple regions (for example, 600 MW of wind in region A and 400 MW of wind in region B), the fraction of total firm capacity added to each region can be specified as:","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"assess(base_system, augmented_system,\n       EFC{EUE}(1000, [\"A\"=>0.6, \"B\"=>0.4]), SequentialMonteCarlo())","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"The EFC() specification accepts multiple optional keyword arguments, which can be provided in any order:","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"p_value: A floating point value giving the maximum allowable p-value from a one-sided hypothesis test. The test considers whether the lower risk metric used during bisection is in fact less than the upper risk metric. If the p-value exceeds this level, the assessment will terminate early due to a lack of statistical power. Note that this only matters for simulation specifications returning estimates with non-zero standard errors, i.e. Monte Carlo-based methods. Defaults to 0.05.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"capacity_gap: An integer giving the maximum desired difference between reported upper and lower bounds on capacity credit. Once the gap between upper and lower bounds is less than or equal to this value, the assessment will terminate. Defaults to 1.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"verbose: A boolean value defaulting to false. If true, PRAS will output informative text describing the progress of the assessment.","category":"page"},{"location":"PRAS/capacitycredit/#Effective-Load-Carrying-Capability-(ELCC)","page":"Capacity Credit Calculation","title":"Effective Load Carrying Capability (ELCC)","text":"","category":"section"},{"location":"PRAS/capacitycredit/#Theory-2","page":"Capacity Credit Calculation","title":"Theory","text":"","category":"section"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"ELCC quantifies the capacity credit of a study resource according to the amount of additional constant load the system can serve while maintaining the same shortfall risk. Like EFC, it requires both a base case system (without the study resource added) and an augmented system (with the study resource added). The analysis then proceeds as follows:","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Assess the shortfall risk of the base system according to the chosen metric (EUE or LOLE).\nAssess the (lower) shortfall risk of the augmented system according to the chosen metric.\nReassess the shortfall risk of the augmented system after adding some amount of constant load. If the risk matches that of the base system, stop. The amount of constant load added is the Effective Load Carrying Capability of the study resource.\nIf the base and augmented+load system risks do not match, change the amount of load added to the augmented system, repeating until the chosen shortfall risk metrics for each system match.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"ELCC calculations in a multi-region system require choosing where load should be increased. There are many possible options, including uniformly distributing new load across each region, distributing load proportional to total energy demand in each region, and adding load only in the region with the study resource. The \"correct\" choice will depend on the goals of the specific analysis. Once the regional load distribution is specified, PRAS uses a bisection method to find the appropriate amount of total load to add to the system.","category":"page"},{"location":"PRAS/capacitycredit/#Usage-2","page":"Capacity Credit Calculation","title":"Usage","text":"","category":"section"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Performing an ELCC assessment in PRAS requires specifying two different SystemModels: one representing the base system, and a second representing the augmented system. It also requires specifying the probabilistic risk metric to use when comparing system risks, an upper bound on the ELCC (usually, the nameplate capacity of the study resource) and to which region(s) the additional load should be added. Finally, the simulation specification should be provided.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"For example, to calculate ELCC based on EUE for a resource intending to serve load in region A, with an upper ELCC bound of 1000 MW (assuming the SystemModels are represented in MW):","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"assess(base_system, augmented_system,\n       ELCC{EUE}(1000, \"A\"), SequentialMonteCarlo())","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"If the load serving assessment is to be spread over multiple regions (for example, 50% of load in region A and 50% in region B), the fraction of additional load added to each region can be specified as:","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"assess(base_system, augmented_system,\n       ELCC{EUE}(1000, [\"A\"=>0.5, \"B\"=>0.5]), SequentialMonteCarlo())","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"The ELCC() specification accepts multiple optional keyword arguments, which can be provided in any order:","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"p_value: A floating point value giving the maximum allowable p-value from a one-sided hypothesis test. The test considers whether the lower risk metric used during bisection is in fact less than the upper risk metric. If the p-value exceeds this level, the assessment will terminate early due to a lack of statistical power. Note that this only matters for simulation specifications returning estimates with non-zero standard errors, i.e. Monte Carlo-based methods. Defaults to 0.05.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"capacity_gap: An integer giving the maximum desired difference between reported upper and lower bounds on capacity credit. Once the gap between upper and lower bounds is less than or equal to this value, the assessment will terminate. Defaults to 1.","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"verbose: A boolean value defaulting to false. If true, PRAS will output informative text describing the progress of the assessment.","category":"page"},{"location":"PRAS/capacitycredit/#Capacity-Credit-Results","page":"Capacity Credit Calculation","title":"Capacity Credit Results","text":"","category":"section"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Both EFC and ELCC assessments return CapacityCreditResult objects. These objects contain information on estimated lower and upper bounds of the capacity credit, as well as additional details about the process through which the capacity credit was calculated. Results can be retrieved as follows:","category":"page"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"cc_result = assess(base_system, augmented_system, EFC{EUE}(1000, \"A\"),\n                   SequentialMonteCarlo())\n\n# Get lower and upper bounds on CC estimate\ncc_lower = minimum(cc_result)\ncc_upper = maximum(cc_result)\n\n# Get both bounds at once\ncc_lower, cc_upper = extrema(cc_result)","category":"page"},{"location":"PRAS/capacitycredit/#References","page":"Capacity Credit Calculation","title":"References","text":"","category":"section"},{"location":"PRAS/capacitycredit/","page":"Capacity Credit Calculation","title":"Capacity Credit Calculation","text":"Zachary, S., & Dent, C. J. (2011). Probability theory of capacity value of additional generation. Proc. IMechE Part O: J. Risk and Reliability, 226, 33-43.","category":"page"},{"location":"PRASCore/api/#PRASCore-API-reference","page":"PRASCore","title":"PRASCore API reference","text":"","category":"section"},{"location":"PRASCore/api/#Systems","page":"PRASCore","title":"Systems","text":"","category":"section"},{"location":"PRASCore/api/#PRASCore.Systems.SystemModel","page":"PRASCore","title":"PRASCore.Systems.SystemModel","text":"SystemModel{N, L, T<:Period, P<:PowerUnit, E<:EnergyUnit}\n\nA SystemModel struct contains a representation of a power system to be studied with PRAS. See system specifications for more  details on components of a system model.\n\nType Parameters\n\nN: Number of timesteps in the system model\nL: Length of each timestep in T units \nT: Time period type (e.g., Hour, Minute)\nP: Power unit type (e.g., MW, GW)\nE: Energy unit type (e.g., MWh, GWh)\n\nFields\n\nregions: Representation of system regions (Type - Regions)\ninterfaces: Information about connections between regions (Type - Interfaces)\ngenerators: Collection of system generators (Type - Generators)\nregion_gen_idxs: Mapping of generators to their respective regions\nstorages: Collection of system storages (Type - Storages)\nregion_stor_idxs: Mapping of storage resources to their respective regions\ngeneratorstorages: Collection of system generation-storages (Type - GeneratorStorages)\nregion_genstor_idxs: Mapping of hybrid resources to their respective regions\nlines: Collection of transmission lines connecting regions (Type - Lines)\ninterface_line_idxs: Mapping of transmission lines to interfaces\ntimestamps: Time range for the simulation period\nattrs: Dictionary of system metadata and attributes\n\nConstructors\n\nSystemModel(regions, interfaces, generators, region_gen_idxs, storages, region_stor_idxs,\n            generatorstorages, region_genstor_idxs, lines, interface_line_idxs,\n            timestamps, [attrs])\n\nCreate a system model with all components specified.\n\nSystemModel(generators, storages, generatorstorages, timestamps, load, [attrs])\n\nCreate a single-node system model with specified generators, storage, and load profile.\n\nSystemModel(regions, interfaces, generators, region_gen_idxs, storages, region_stor_idxs,\n            generatorstorages, region_genstor_idxs, lines, interface_line_idxs,\n            timestamps::StepRange{DateTime}, [attrs])\n\nCreate a system model with DateTime timestamps (will be converted to UTC time zone).\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Systems.Regions","page":"PRASCore","title":"PRASCore.Systems.Regions","text":"Regions{N,P<:PowerUnit}\n\nA struct representing regions within a power system.\n\nType Parameters\n\nN: Number of timesteps in the system model\nP: The power unit used for demand measurements, subtype of PowerUnit\n\nFields\n\nnames: Name of region (unique)\nload: Aggregated electricity demand in each region for each timeperiod, in power_units (P)\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Systems.Generators","page":"PRASCore","title":"PRASCore.Systems.Generators","text":"Generators{N,L,T<:Period,P<:PowerUnit}\n\nA struct representing generating assets within a power system.\n\nType Parameters\n\nN: Number of timesteps in the system model\nL: Length of each timestep in T units \nT: The time period type used for temporal representation, subtype of Period\nP: The power unit used for capacity measurements, subtype of PowerUnit\n\nFields\n\nnames: Name of generator\ncategories: Category of generator\ncapacity: Maximum available generation capacity in each timeperiod, expressed  in units given by the power_units (P) type parameter\nλ (failure probability): probability the generator transitions from  operational to forced outage during a given simulation timestep (unitless)\nμ (repair probability): probability the generator transitions from forced  outage to operational during a given simulation timestep (unitless)\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Systems.Storages","page":"PRASCore","title":"PRASCore.Systems.Storages","text":"Storages{N,L,T<:Period,P<:PowerUnit,E<:EnergyUnit}\n\nA struct representing storage devices in the system.\n\nType Parameters\n\nN: Number of timesteps in the system model\nL: Length of each timestep in T units\nT: The time period type used for temporal representation, subtype of Period\nP: The power unit used for capacity measurements, subtype of PowerUnit\nE: The energy unit used for energy storage, subtype of EnergyUnit\n\nFields\n\nnames: Name of storage device\ncategories: Category of storage device\ncharge_capacity: Maximum available charging capacity for each storage unit in each timeperiod, expressed in units given by the power_units (P) type parameter\ndischarge_capacity: Maximum available discharging capacity for each storage unit in each timeperiod, expressed in units given by the power_units (P) type parameter\nenergy_capacity: Maximum available energy storage capacity for each storage unit in each timeperiod, expressed in units given by the energy_units (E) type parameter\ncharge_efficiency: Ratio of power injected into the storage device's reservoir to power withdrawn from the grid, for each storage unit in each timeperiod. Unitless.\ndischarge_efficiency: Ratio of power injected into the grid to power withdrawn from the storage device's reservoir, for each storage unit in each timeperiod. Unitless.\ncarryover_efficiency: Ratio of energy available in the storage device's reservoir at the beginning of one period to energy retained at the end of the previous period, for each storage unit in each timeperiod. Unitless.\nλ (failure probability): Probability the unit transitions from operational to forced outage during a given simulation timestep, for each storage unit in each timeperiod. Unitless.\nμ (repair probability): Probability the unit transitions from forced outage to operational during a given simulation timestep, for each storage unit in each timeperiod. Unitless.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Systems.GeneratorStorages","page":"PRASCore","title":"PRASCore.Systems.GeneratorStorages","text":"GeneratorStorages{N,L,T<:Period,P<:PowerUnit,E<:EnergyUnit}\n\nA struct representing generator-storage hybrid devices within a power system.\n\nType Parameters\n\nN: Number of timesteps in the system model\nL: Length of each timestep in T units\nT: The time period type used for temporal representation, subtype of Period\nP: The power unit used for capacity measurements, subtype of PowerUnit\nE: The energy unit used for energy storage, subtype of EnergyUnit\n\nFields\n\nnames: Name of generator-storage unit\ncategories: Category of generator-storage unit\ncharge_capacity: Maximum available charging capacity for each generator-storage unit in each timeperiod, in power_units (P)\ndischarge_capacity: Maximum available discharging capacity for each generator-storage unit in each timeperiod, in power_units (P)\nenergy_capacity: Maximum available energy storage capacity for each generator-storage unit in each timeperiod, in energy_units (E)\ncharge_efficiency: Ratio of power injected into the device's reservoir to power withdrawn from the grid, for each generator-storage unit in each timeperiod. Unitless.\ndischarge_efficiency: Ratio of power injected into the grid to power withdrawn from the device's reservoir, for each generator-storage unit in each timeperiod. Unitless.\ncarryover_efficiency: Ratio of energy available in the device's reservoir at the beginning of one period to energy retained at the end of the previous period, for each generator-storage unit in each timeperiod. Unitless.\ninflow: Exogenous power inflow available to each generator-storage unit in each timeperiod, in power_units (P)\ngridwithdrawal_capacity: Maximum available capacity to withdraw power from the grid for each generator-storage unit in each timeperiod, in power_units (P)\ngridinjection_capacity: Maximum available capacity to inject power to the grid for each generator-storage unit in each timeperiod, in power_units (P)\nλ (failure probability): Probability the unit transitions from operational to forced outage during a given simulation timestep, for each generator-storage unit in each timeperiod. Unitless.\nμ (repair probability): Probability the unit transitions from forced outage to operational during a given simulation timestep, for each generator-storage unit in each timeperiod. Unitless.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Systems.DemandResponses","page":"PRASCore","title":"PRASCore.Systems.DemandResponses","text":"DemandResponses{N,L,T<:Period,P<:PowerUnit,E<:EnergyUnit}\n\nA struct representing demand response devices in the system.\n\nType Parameters\n\nN: Number of timesteps in the system model\nL: Length of each timestep in T units\nT: The time period type used for temporal representation, subtype of Period\nP: The power unit used for capacity measurements, subtype of PowerUnit\nE: The energy unit used for energy storage, subtype of EnergyUnit\n\nFields\n\nnames: Name of demand response device\ncategories: Category of demand response device\nborrow_capacity: Maximum available borrowing capacity for each demand response unit in each timeperiod, expressed in units given by the power_units (P) type parameter\npayback_capacity: Maximum available payback capacity for each demand response unit in each timeperiod, expressed in units given by the power_units (P) type parameter\nenergy_capacity: Maximum available energy capable of being held for each demand response unit in each timeperiod, expressed in units given by the energy_units (E) type parameter\nborrowed_energy_interest: Growth or decay rate of borrowed energy in the demand response device from the beginning of one period to energy retained at the end of the previous period, for each demand response unit in each timeperiod. A borrowed_energy_interest of 0.0 has no growth or decay. Unitless.\nallowable_payback_period: Maximum number of time steps a demand response device can hold borrowed load.  Any energy still contained at the end of the period will be counted as unserved load for that hour.  If borrowed load is paid back before the end of the allowable_payback_period, counter is reset upn further use. (T) type parameter\nλ (failure probability): Probability the unit transitions from operational to forced outage during a given simulation timestep, for each storage unit in each timeperiod. Unitless.\nμ (repair probability): Probability the unit transitions from forced outage to operational during a given simulation timestep, for each storage unit in each timeperiod. Unitless.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Systems.Lines","page":"PRASCore","title":"PRASCore.Systems.Lines","text":"Lines{N,L,T<:Period,P<:PowerUnit}\n\nA struct representing individual transmission lines between regions in a power system.\n\nType Parameters\n\nN: Number of timesteps in the system model\nL: Length of each timestep in T units\nT: The time period type used for temporal representation, subtype of Period\nP: The power unit used for capacity measurements, subtype of PowerUnit\n\nFields\n\nnames: Name of line\ncategories: Category of line\nforward_capacity: Maximum available power transfer capacity from region_from to region_to along the line, for each line in each timeperiod, in power_units (P)\nbackward_capacity: Maximum available power transfer capacity from region_to to region_from along the line, for each line in each timeperiod, in power_units (P)\nλ (failure probability): Probability the line transitions from operational to forced outage during a given simulation timestep, for each line in each timeperiod. Unitless.\nμ (repair probability): Probability the line transitions from forced outage to operational during a given simulation timestep, for each line in each timeperiod. Unitless.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Systems.Interfaces","page":"PRASCore","title":"PRASCore.Systems.Interfaces","text":"Interfaces{N,P<:PowerUnit}\n\nA struct representing transmission interfaces between regions in a power system.\n\nType Parameters\n\nN: Number of timesteps in the system model\nP: The power unit used for interface limits, subtype of PowerUnit\n\nFields\n\nregions_from: Index of the first region connected by the interface\nregions_to: Index of the second region connected by the interface\nlimit_forward: Maximum possible total power transfer from regions_from to regions_to, for each interface in each timeperiod, in power_units (P)\nlimit_backward: Maximum possible total power transfer from regions_to to regions_from, for each interface in each timeperiod, in power_units (P)\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#Simulations","page":"PRASCore","title":"Simulations","text":"","category":"section"},{"location":"PRASCore/api/#PRASCore.Simulations.assess-Tuple{SystemModel, SequentialMonteCarlo, Vararg{PRASCore.Results.ResultSpec}}","page":"PRASCore","title":"PRASCore.Simulations.assess","text":"assess(system::SystemModel, method::SequentialMonteCarlo, resultspecs::ResultSpec...)\n\nRun a Sequential Monte Carlo simulation on a system using the method data and return resultspecs.\n\nArguments\n\nsystem::SystemModel: PRAS data structure\nmethod::SequentialMonteCarlo: method for PRAS analysis\nresultspecs::ResultSpec...: PRAS metric for metrics like Shortfall missing generation\n\nReturns\n\nresults::Tuple{Vararg{ResultAccumulator{SequentialMonteCarlo}}}: PRAS metric results\n\n\n\n\n\n","category":"method"},{"location":"PRASCore/api/#PRASCore.Simulations.DispatchProblem","page":"PRASCore","title":"PRASCore.Simulations.DispatchProblem","text":"DispatchProblem(sys::SystemModel)\n\nCreate a min-cost flow problem for the multi-region max power delivery problem with generation and storage discharging in decreasing order of priority, storage charging with excess capacity and demand response devices enabling load shed and shift functionality. Storage, GeneratorStorage, and Demand Response devices within a region are represented individually on the network.\n\nThis involves injections/withdrawals at one node (regional capacity surplus/shortfall) for each modelled region, as well as two/three nodes associated with each Storage/GeneratorStorage device, and a supplementary \"slack\" node in the network that can absorb undispatched power or pass unserved energy or unused charging capability through to satisfy power balance constraints. Demand Response devices are represented in a structurally similar manner as storage charging and discharging.\n\nFlows from the generation nodes are free, while flows to charging and from discharging nodes are costed or rewarded according to the time-to-discharge of the storage device, ensuring efficient coordination across units, while enforcing that storage is only discharged once generation capacity is exhausted (implying an operational strategy that prioritizes resource adequacy over economic arbitrage). This is based on the storage dispatch strategy of Evans, Tindemans, and Angeli, as outlined in \"Minimizing Unserved Energy Using Heterogenous Storage Units\" (IEEE Transactions on Power Systems, 2019). Demand Response devices will borrow energy in devices with the  longest payback window first, and vice versa for payback energy.  Demand Response devices are utilized only after discharging all storage/genstor and paid back before storage/genstor charging.\n\nFlows to the charging node have an attenuated negative cost (reward), incentivizing immediate storage charging if generation and transmission allows it, while avoiding charging by discharging other storage (since that would incur an overall positive cost).\n\nFlows to the slack node (representing unused generation or storage discharge capacity) are free, but flows from the slack node to serve load incur the lost load penalty of 9999. Flows from the slack node in lieu of storage charging or discharging are free.\n\nFlows on transmission interfaces assume a hurdle rate of 1 to keep unserved energy close to the source of the shortage and eliminate loop flows. This has the side-effect of disincentivising wheeling power across multiple regions for charging purposes, however.\n\nNodes in the problem are ordered as:\n\nRegions generation surplus/shortfall (Regions order)\nStorage discharge capacity (Storage order)\nStorage charge capacity (Storage order)\nGenerationStorage inflow capacity (GeneratorStorage order)\nGenerationStorage discharge capacity (GeneratorStorage order)\nGenerationStorage grid injection (GeneratorStorage order)\nGenerationStorage charge capacity (GeneratorStorage order)\nDemandResponse payback capacity (DemandResponse order)\nDemandResponse borrowing capacity (DemandResponse order)\nSlack node\n\nEdges are ordered as:\n\nRegions demand unserved (Regions order)\nRegions generation unused (Regions order)\nInterfaces forward flow (Interfaces order)\nInterfaces reverse flow (Interfaces order)\nStorage discharge to grid (Storage order)\nStorage discharge unused (Storage order)\nStorage charge from grid (Storage order)\nStorage charge unused (Storage order)\nGenerationStorage discharge to grid (GeneratorStorage order)\nGenerationStorage discharge unused (GeneratorStorage order)\nGenerationStorage inflow to grid (GenerationStorage order)\nGenerationStorage total to grid (GeneratorStorage order)\nGenerationStorage charge from grid (GeneratorStorage order)\nGenerationStorage charge from inflow (GeneratorStorage order)\nGenerationStorage charge unused (GeneratorStorage order)\nGenerationStorage inflow unused (GeneratorStorage order)\nDemandResponse payback to grid (DemandResponse order)\nDemandResponse payback unused (DemandResponse order)\nDemandResponse borrowing from grid (DemandResponse order)\nDemandResponse borrowing unused (DemandResponse order)\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Simulations.SequentialMonteCarlo","page":"PRASCore","title":"PRASCore.Simulations.SequentialMonteCarlo","text":"SequentialMonteCarlo(;\n    samples::Int=10_000,\n    seed::Integer=rand(UInt64),\n    verbose::Bool=false,\n    threaded::Bool=true\n)\n\nSequential Monte Carlo simulation parameters for PRAS analysis\n\nIt it recommended that you fix the random seed for reproducibility.\n\nArguments\n\nsamples::Int=10_000: Number of samples\nseed::Integer=rand(UInt64): Random seed\nverbose::Bool=false: Print progress\nthreaded::Bool=true: Use multi-threading\n\nReturns\n\nSequentialMonteCarlo: PRAS simulation specification\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#Results","page":"PRASCore","title":"Results","text":"","category":"section"},{"location":"PRASCore/api/#PRASCore.Results.LOLE","page":"PRASCore","title":"PRASCore.Results.LOLE","text":"LOLE\n\nLOLE reports loss of load expectation over a particular time period and regional extent. When the reporting period is a single simulation timestep, the metric is equivalent to loss of load probability (LOLP).\n\nContains both the estimated value itself as well as the standard error of that estimate, which can be extracted with val and stderror, respectively.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.EUE","page":"PRASCore","title":"PRASCore.Results.EUE","text":"EUE\n\nEUE reports expected unserved energy over a particular time period and regional extent.\n\nContains both the estimated value itself as well as the standard error of that estimate, which can be extracted with val and stderror, respectively.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.NEUE","page":"PRASCore","title":"PRASCore.Results.NEUE","text":"NEUE\n\nNEUE reports normalized expected unserved energy over a regional extent.\n\nContains both the estimated value itself as well as the standard error of that estimate, which can be extracted with val and stderror, respectively.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.Shortfall","page":"PRASCore","title":"PRASCore.Results.Shortfall","text":"Shortfall\n\nThe Shortfall result specification reports expectation-based resource adequacy risk metrics such as EUE and LOLE, producing a ShortfallResult.\n\nA ShortfallResult can be directly indexed by a region name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating  the average unserved energy in that region and timestep. However, in most cases it's simpler to use EUE and LOLE constructors to directly retrieve standard risk metrics.\n\nExample:\n\nshortfall, =\n    assess(sys, SequentialMonteCarlo(samples=1000), Shortfall())\n\nperiod = ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")\n\n# Unserved energy mean and standard deviation\nsf_mean, sf_std = shortfall[\"Region A\", period]\n\n# System-wide risk metrics\neue = EUE(shortfall)\nlole = LOLE(shortfall)\nneue = NEUE(shorfall)\n\n# Regional risk metrics\nregional_eue = EUE(shortfall, \"Region A\")\nregional_lole = LOLE(shortfall, \"Region A\")\nregional_neue = NEUE(shortfall, \"Region A\")\n\n# Period-specific risk metrics\nperiod_eue = EUE(shortfall, period)\nperiod_lolp = LOLE(shortfall, period)\n\n# Region- and period-specific risk metrics\nperiod_eue = EUE(shortfall, \"Region A\", period)\nperiod_lolp = LOLE(shortfall, \"Region A\", period)\n\nSee ShortfallSamples for recording sample-level shortfall results.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.ShortfallSamples","page":"PRASCore","title":"PRASCore.Results.ShortfallSamples","text":"ShortfallSamples\n\nThe ShortfallSamples result specification reports sample-level unserved energy outcomes, producing a ShortfallSamplesResult.\n\nA ShortfallSamplesResult can be directly indexed by a region name and a timestamp to retrieve a vector of sample-level unserved energy results in that region and timestep. EUE and LOLE constructors can also be used to retrieve standard risk metrics.\n\nExample:\n\nshortfall, =\n    assess(sys, SequentialMonteCarlo(samples=10), ShortfallSamples())\n\nperiod = ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")\n\nsamples = shortfall[\"Region A\", period]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\n# System-wide risk metrics\neue = EUE(shortfall)\nlole = LOLE(shortfall)\nneue = NEUE(shortfall)\n\n# Regional risk metrics\nregional_eue = EUE(shortfall, \"Region A\")\nregional_lole = LOLE(shortfall, \"Region A\")\nregional_neue = NEUE(shortfall, \"Region A\")\n\n# Period-specific risk metrics\nperiod_eue = EUE(shortfall, period)\nperiod_lolp = LOLE(shortfall, period)\n\n# Region- and period-specific risk metrics\nperiod_eue = EUE(shortfall, \"Region A\", period)\nperiod_lolp = LOLE(shortfall, \"Region A\", period)\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See Shortfall for average shortfall outcomes when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.Surplus","page":"PRASCore","title":"PRASCore.Results.Surplus","text":"Surplus\n\nThe Surplus result specification reports unused generation and storage discharge capability of Regions, producing a SurplusResult.\n\nA SurplusResult can be indexed by region name and timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average unused capacity in that region and timestep.\n\nExample:\n\nsurplus, =\n    assess(sys, SequentialMonteCarlo(samples=1000), Surplus())\n\nsurplus_mean, surplus_std =\n    surplus[\"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nSee SurplusSamples for sample-level surplus results.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.SurplusSamples","page":"PRASCore","title":"PRASCore.Results.SurplusSamples","text":"SurplusSamples\n\nThe SurplusSamples result specification reports sample-level unused generation and storage discharge capability of Regions, producing a SurplusSamplesResult.\n\nA SurplusSamplesResult can be indexed by region name and timestamp to retrieve a vector of sample-level surplus values in that region and timestep.\n\nExample:\n\nsurplus, =\n    assess(sys, SequentialMonteCarlo(samples=10), SurplusSamples())\n\nsamples = surplus[\"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See Surplus for estimated average surplus values when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.Flow","page":"PRASCore","title":"PRASCore.Results.Flow","text":"Flow\n\nThe Flow result specification reports the estimated average flow across transmission Interfaces, producing a FlowResult.\n\nA FlowResult can be indexed by a directional Pair of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average net flow magnitude and direction relative to the given directed interface in that timestep. For a query of \"Region A\" => \"Region B\", if estimated average flow was from A to B, the reported value would be positive, while if average flow was in the reverse direction, from B to A, the value would be negative.\n\nExample:\n\nflows, =\n    assess(sys, SequentialMonteCarlo(samples=1000), Flow())\n\nflow_mean, flow_std =\n    flows[\"Region A\" => \"Region B\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\nflow2_mean, flow2_std =\n    flows[\"Region B\" => \"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n@assert flow_mean == -flow2_mean\n\nSee FlowSamples for sample-level flow results.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.FlowSamples","page":"PRASCore","title":"PRASCore.Results.FlowSamples","text":"FlowSamples\n\nThe FlowSamples result specification reports the sample-level magnitude and direction of power flows across Interfaces, producing a FlowSamplesResult.\n\nA FlowSamplesResult can be indexed by a directional Pair of region names and a timestamp to retrieve a vector of sample-level net flow magnitudes and directions relative to the given directed interface in that timestep. For a query of \"Region A\" => \"Region B\", if flow in one sample was from A to B, the reported value would be positive, while if flow was in the reverse direction, from B to A, the value would be negative.\n\nExample:\n\nflows, =\n    assess(sys, SequentialMonteCarlo(samples=10), FlowSamples())\n\nsamples = flows[\"Region A\" => \"Region B\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nsamples2 = flows[\"Region B\" => \"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples == -samples2\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See Flow for estimated average flow results when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.Utilization","page":"PRASCore","title":"PRASCore.Results.Utilization","text":"Utilization\n\nThe Utilization result specification reports the estimated average absolute utilization of Interfaces, producing a UtilizationResult.\n\nWhereas Flow reports the average directional power transfer across an interface, Utilization reports the absolute value of flow relative to the interface's transfer capability (counting the effects of line outages). For example, a symmetrically-constrained interface which is fully congested with max power flowing in one direction in half of the samples, and the other direction in the remaining samples, would have an average flow of 0 MW, but an average utilization of 100%.\n\nA UtilizationResult can be indexed by a Pair of region names and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average utilization of the interface. Given the absolute value nature of the outcome, results are independent of direction. Querying \"Region A\" => \"Region B\" will yield the same result as \"Region B\" => \"Region A\".\n\nExample:\n\nutils, =\n    assess(sys, SequentialMonteCarlo(samples=1000), Utilization())\n\nutil_mean, util_std =\n    utils[\"Region A\" => \"Region B\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nutil2_mean, util2_std =\n    utils[\"Region B\" => \"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert util_mean == util2_mean\n\nSee UtilizationSamples for sample-level utilization results.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.UtilizationSamples","page":"PRASCore","title":"PRASCore.Results.UtilizationSamples","text":"UtilizationSamples\n\nThe UtilizationSamples result specification reports the sample-level absolute utilization of Interfaces, producing a UtilizationSamplesResult.\n\nWhereas FlowSamples reports the directional power transfer across an interface, UtilizationSamples reports the absolute value of flow relative to the interface's transfer capability (counting the effects of line outages). For example, a 100 MW symmetrically-constrained interface which is fully congested may have a flow of +100 or -100 MW, but in both cases the utilization will be 100%. If a 50 MW line in the interface went on outage, flow may drop to +50 or -50 MW, but utilization would remain at 100%.\n\nA UtilizationSamplesResult can be indexed by a Pair of region names and a timestamp to retrieve a vector of sample-level utilizations of the interface in that timestep. Given the absolute value nature of the outcome, results are independent of direction. Querying \"Region A\" => \"Region B\" will yield the same result as \"Region B\" => \"Region A\".\n\nExample:\n\nutils, =\n    assess(sys, SequentialMonteCarlo(samples=10), UtilizationSamples())\n\nsamples =\n    utils[\"Region A\" => \"Region B\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nsamples2 =\n    utils[\"Region B\" => \"Region A\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples == samples2\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See Utilization for sample-averaged utilization results when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.GeneratorAvailability","page":"PRASCore","title":"PRASCore.Results.GeneratorAvailability","text":"GeneratorAvailability\n\nThe GeneratorAvailability result specification reports the sample-level discrete availability of Generators, producing a GeneratorAvailabilityResult.\n\nA GeneratorAvailabilityResult can be indexed by generator name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\ngenavail, =\n    assess(sys, SequentialMonteCarlo(samples=10), GeneratorAvailability())\n\nsamples = genavail[\"MyGenerator123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.GeneratorStorageAvailability","page":"PRASCore","title":"PRASCore.Results.GeneratorStorageAvailability","text":"GeneratorStorageAvailability\n\nThe GeneratorStorageAvailability result specification reports the sample-level discrete availability of GeneratorStorages, producing a GeneratorStorageAvailabilityResult.\n\nA GeneratorStorageAvailabilityResult can be indexed by generator-storage name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\ngenstoravail, =\n    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageAvailability())\n\nsamples = genstoravail[\"MyGenerator123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.GeneratorStorageEnergy","page":"PRASCore","title":"PRASCore.Results.GeneratorStorageEnergy","text":"GeneratorStorageEnergy\n\nThe GeneratorStorageEnergy result specification reports the average state of charge of GeneratorStorages, producing a GeneratorStorageEnergyResult.\n\nA GeneratorStorageEnergyResult can be indexed by generator-storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given generator-storage device in that timestep.\n\nExample:\n\ngenstorenergy, =\n    assess(sys, SequentialMonteCarlo(samples=1000), GeneratorStorageEnergy())\n\nsoc_mean, soc_std =\n    genstorenergy[\"MyGeneratorStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nSee GeneratorStorageEnergySamples for sample-level generator-storage states of charge.\n\nSee StorageEnergy for average storage states of charge.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.GeneratorStorageEnergySamples","page":"PRASCore","title":"PRASCore.Results.GeneratorStorageEnergySamples","text":"GeneratorStorageEnergySamples\n\nThe GeneratorStorageEnergySamples result specification reports the sample-level state of charge of GeneratorStorages, producing a GeneratorStorageEnergySamplesResult.\n\nA GeneratorStorageEnergySamplesResult can be indexed by generator-storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.\n\nExample:\n\ngenstorenergy, =\n    assess(sys, SequentialMonteCarlo(samples=10), GeneratorStorageEnergySamples())\n\nsamples = genstorenergy[\"MyGeneratorStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See GeneratorStorageEnergy for estimated average generator-storage state of charge when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.StorageAvailability","page":"PRASCore","title":"PRASCore.Results.StorageAvailability","text":"StorageAvailability\n\nThe StorageAvailability result specification reports the sample-level discrete availability of Storages, producing a StorageAvailabilityResult.\n\nA StorageAvailabilityResult can be indexed by storage device name and a timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\nstoravail, =\n    assess(sys, SequentialMonteCarlo(samples=10), StorageAvailability())\n\nsamples = storavail[\"MyStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.StorageEnergy","page":"PRASCore","title":"PRASCore.Results.StorageEnergy","text":"StorageEnergy\n\nThe StorageEnergy result specification reports the average state of charge of Storages, producing a StorageEnergyResult.\n\nA StorageEnergyResult can be indexed by storage device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy level for the given storage device in that timestep.\n\nExample:\n\nstorenergy, =\n    assess(sys, SequentialMonteCarlo(samples=1000), StorageEnergy())\n\nsoc_mean, soc_std =\n    storenergy[\"MyStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nSee StorageEnergySamples for sample-level storage states of charge.\n\nSee GeneratorStorageEnergy for average generator-storage states of charge.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.StorageEnergySamples","page":"PRASCore","title":"PRASCore.Results.StorageEnergySamples","text":"StorageEnergySamples\n\nThe StorageEnergySamples result specification reports the sample-level state of charge of Storages, producing a StorageEnergySamplesResult.\n\nA StorageEnergySamplesResult can be indexed by storage device name and a timestamp to retrieve a vector of sample-level charge states for the device in the given timestep.\n\nExample:\n\nstorenergy, =\n    assess(sys, SequentialMonteCarlo(samples=10), StorageEnergySamples())\n\nsamples = storenergy[\"MyStorage123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See StorageEnergy for estimated average storage state of charge when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.DemandResponseAvailability","page":"PRASCore","title":"PRASCore.Results.DemandResponseAvailability","text":"DemandResponseAvailability\n\nThe DemandResponseAvailability result specification reports the sample-level discrete availability of DemandResponses, producing a DemandResponseAvailabilityResult.\n\nA DemandResponseAvailabilityResult can be indexed by demand response device name and a timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\ndravail, =\n    assess(sys, SequentialMonteCarlo(samples=10), DemandResponseAvailability())\n\nsamples = dravail[\"MyDR123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.DemandResponseEnergy","page":"PRASCore","title":"PRASCore.Results.DemandResponseEnergy","text":"DemandResponseEnergy\n\nThe DemandResponseEnergy result specification reports the average energy borrowed of DemandResponses, producing a DemandResponseEnergyResult.\n\nA DemandResponseEnergyResult can be indexed by demand response device name and a timestamp to retrieve a tuple of sample mean and standard deviation, estimating the average energy borrowed level for the given demand response device in that timestep.\n\nExample:\n\ndrenergy, =\n    assess(sys, SequentialMonteCarlo(samples=1000), DemandResponseEnergy())\n\nsoc_mean, soc_std =\n    drenergy[\"MyDemandResponse123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\nSee DemandResponseEnergySamples for sample-level demand response states of borrowed energy.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.DemandResponseEnergySamples","page":"PRASCore","title":"PRASCore.Results.DemandResponseEnergySamples","text":"DemandResponseEnergySamples\n\nThe DemandResponseEnergySamples result specification reports the sample-level state of borrowed energy of DemandResponses, producing a DemandResponseEnergySamplesResult.\n\nA DemandResponseEnergySamplesResult can be indexed by demand response device name and a timestamp to retrieve a vector of sample-level borrowed energy states for the device in the given timestep.\n\nExample:\n\ndemandresponseenergy, =\n    assess(sys, SequentialMonteCarlo(samples=10), DemandResponseEnergySamples())\n\nsamples = demandresponseenergy[\"MyDemandResponse123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Float64}\n@assert length(samples) == 10\n\nNote that this result specification requires large amounts of memory for larger sample sizes. See DemandResponseEnergy for estimated average demand response borrowed energy when sample-level granularity isn't required.\n\n\n\n\n\n","category":"type"},{"location":"PRASCore/api/#PRASCore.Results.LineAvailability","page":"PRASCore","title":"PRASCore.Results.LineAvailability","text":"LineAvailability\n\nThe LineAvailability result specification reports the sample-level discrete availability of Lines, producing a LineAvailabilityResult.\n\nA LineAvailabilityResult can be indexed by line name and timestamp to retrieve a vector of sample-level availability states for the unit in the given timestep. States are provided as a boolean with true indicating that the unit is available and false indicating that it's unavailable.\n\nExample:\n\nlineavail, =\n    assess(sys, SequentialMonteCarlo(samples=10), LineAvailability())\n\nsamples = lineavail[\"MyLine123\", ZonedDateTime(2020, 1, 1, 0, tz\"UTC\")]\n\n@assert samples isa Vector{Bool}\n@assert length(samples) == 10\n\n\n\n\n\n","category":"type"},{"location":"SystemModel_HDF5_spec/#prasfile","page":".pras File Format","title":"SystemModel HDF5 representation specification","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"This document specifies a representation of the PRAS SystemModel data structure in terms of objects like  groups,  datatypes, and  datasets in an HDF5 file. This specification is version-controlled in the same repository as the SystemModel source code: any time the SystemModel definition is changed, those updates are expected to be reconciled with this document as appropriate. The version of this specification should therefore be taken as the version of the package containing this file.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Note: A useful reference for HDF5 file structure concepts is the [HDF5 Glossary](https://support.hdfgroup.org/documentation/hdf5/latest/gls.html). This document contains links to documentation entries to explain HDF5 terms when used for the first time._","category":"page"},{"location":"SystemModel_HDF5_spec/#Filename-extension","page":".pras File Format","title":"Filename extension","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"By convention, HDF5 file representations of a PRAS SystemModel struct are often given \".pras\" filename extensions. This is merely a convenience to more readily distinguish such files from other HDF5 files on the filesystem (which will likely have \".h5\" or \".hdf5\" extensions), and is purely optional.","category":"page"},{"location":"SystemModel_HDF5_spec/#PRAS-terminology","page":".pras File Format","title":"PRAS terminology","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"In the following specification, generators, generator-storage units, storage devices, and lines are sometimes refered to generically as \"resources\". Similarly, regions (a grouping of generators, generator-storage units, and storage devices) and interfaces (a grouping of lines) are sometimes referred to generically as \"resource collections\".","category":"page"},{"location":"SystemModel_HDF5_spec/#HDF5-File-Structure","page":".pras File Format","title":"HDF5 File Structure","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/#Root-group-attributes","page":".pras File Format","title":"Root group attributes","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The HDF5 file must define seven attributes on the root group.  There can also be additional attributes describing the system, including data descriptors used  in creating the system.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"These attributes are mandatory:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"pras_dataversion, signalling that this file is a representation of a PRAS SystemModel and providing the version of this specification used to create the file\nstart_timestamp, providing the timestamp of the first period of the simulation in ISO-8601 format\ntimestep_count, providing the number of timesteps in the simulation\ntimestep_length, providing the length (in timestep_units) of each timestep in the simulation\ntimestep_unit, providing the time units for timestep_length\npower_unit, providing the units for power-related data\nenergy_unit, providing the units for energy-related data","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"There can be any number of optional attributes which need to also be defined as  key-value pairs and both the key and value are strings of characters.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each of the required attributes and their contents are explained in more detail below.","category":"page"},{"location":"SystemModel_HDF5_spec/#pras_dataversion","page":".pras File Format","title":"pras_dataversion","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The version of this HDF5 representation specification used to create the  HDF5 file should be stored in an attribute of the file's root group labelled pras_dataversion. The attribute should provide a single ASCII string, taking the value of the abridged semantic versioning representation of the specification version, vX.Y.Z, where X, Y, and Z represent the major, minor, and patch version numbers of the specification, respectively.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"As discussed above, the version of the specification is the same as the version of the PRASBase.jl package providing the specification, and so should match the version provided in the package's Project.toml file.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"(A given version of PRASBase.jl will check this attribute to determine if it is capable of reading the provided file, and if so, how to do so. While PRASBase is usually capable of reading files associated with PRASBase versions older than itself, it can only write files associated with its own version.)","category":"page"},{"location":"SystemModel_HDF5_spec/#start_timestamp","page":".pras File Format","title":"start_timestamp","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The starting timestamp for the system simulation should be stored in an attribute of the file's root group labelled start_timestamp, as a single 25-character, ISO-8601-compliant ASCII string in a format matching 2020-12-31T23:59:59-07:00, providing year, month, day, hour, minute, second, and timezone offset from UTC (in that order).","category":"page"},{"location":"SystemModel_HDF5_spec/#timestep_count","page":".pras File Format","title":"timestep_count","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The total number of timesteps in the simulation should be stored in an attribute of the file's root group labelled timestep_count, as a single integer. The attribute value should match the number of rows (in C/HDF5 row-major format) in each property dataset in the various resource and resource collection groups.","category":"page"},{"location":"SystemModel_HDF5_spec/#timestep_length","page":".pras File Format","title":"timestep_length","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The length of a single timestep (in terms of the units defined by timestep_unit) should be stored in an attribute of the file's root group labelled timestep_length, as a single integer.","category":"page"},{"location":"SystemModel_HDF5_spec/#timestep_unit","page":".pras File Format","title":"timestep_unit","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The units for timestep_length should be stored in an attribute of the file's root group labelled timestep_unit, as a single ASCII string. The following are recognized values for the string to take:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"sec indicates the units are seconds\nmin indicates the units are minutes\nh indicates the units are hours\nd indicates the units are days","category":"page"},{"location":"SystemModel_HDF5_spec/#power_unit","page":".pras File Format","title":"power_unit","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The units for all parameters quantified in terms of power should be stored in an attribute of the file's root group labelled power_unit, as a single ASCII string. The following are recognized values for the string to take:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"kW indicates power data is in units of kilowatts\nMW indicates power data is in units of megawatts\nGW indicates power data is in units of gigawatts\nTW indicates power data is in units of terawatts","category":"page"},{"location":"SystemModel_HDF5_spec/#energy_unit","page":".pras File Format","title":"energy_unit","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The units for all parameters quantified in terms of energy should be stored in an attribute of the file's root group labelled energy_unit, as a single ASCII string. The following are recognized values for the string to take:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"kWh indicates power data is in units of kilowatt-hours\nMWh indicates power data is in units of megawatt-hours\nGWh indicates power data is in units of gigawatt-hours\nTWh indicates power data is in units of terawatt-hours","category":"page"},{"location":"SystemModel_HDF5_spec/#Resource-/-resource-collection-data","page":".pras File Format","title":"Resource / resource collection data","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The file may define the following six groups as children of the root group. At least two groups are mandatory.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The file must include:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"regions, containing datasets describing regions in the system. This group is mandatory as any system must have at least one region","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The file must include at least one of:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"generators, containing datasets describing generators in the system\ngeneratorstorages, containing datasets describing generator-storage units in the system","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The file may include (optional):","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"storages, containing datasets describing storage devices in the system\ninterfaces, containing datasets describing collections of lines between regions in the system. This group must be included if lines is included and must not be included if lines is omitted.\nlines, containing datasets describing transmission lines between regions in the system. This group must be included if interfaces is included and must not be included if interfaces is omitted.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"For simplicity, the class of system resources or resource collections described by a given group are referred to as \"group entities\" in the following paragraphs.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each group contains one _core dataset providing static parameters and/or relations for the group entities, in the form of a vector / one-dimensional array of compound datatype instances. These datasets may use HDF5's automatic compression features to reduce filesize.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each group also contains one or more datasets representing (potentially) time-varying properties of the group entities. These datasets should be matrices / two-dimensional arrays of unsigned 32-bit integers or 64-bit floating point numbers, depending on the property in question. These datasets may also use HDF5's automatic compression features to reduce filesize.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The size of the inner dimension of the array (number of columns in C/HDF5 row-major format, number of rows in Julia/MATLAB/Fortran column-major format) should match the number of group entities in the system, with entity data provided in the same order as the entities are defined in the _core sibling dataset.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The size of the outer dimension of the array (number of rows in C/HDF5 row-major format, number of columns in Julia/MATLAB/Fortran column-major format) should match the number of timesteps to be simulated (as provided by the timesteps_count root attribute). Data should be chronologically increasing within a single column (row-major) / row (column-major)","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Specific details for each of these groups and their required contents are provided below.","category":"page"},{"location":"SystemModel_HDF5_spec/#regions-group","page":".pras File Format","title":"regions group","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Information relating to the regions of the represented system is stored in the mandatory regions group inside the root group. This group should contain two datasets, one (named _core) providing core static data about each region and one providing (potentially) time-varying data.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The _core dataset should be a one-dimensional array storing instances of a compound datatype with the following fields (in order):","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"name: 128-byte ASCII string. Stores the unique name of each region.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each region in the system corresponds to a single instance of the compound datatype, so the array should have as many elements as there are regions in the system.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The regions group should contain the following datasets describing (potentially) time-varying properties of the system regions:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"load, as unsigned 32-bit integers representing aggregated electricity demand in each region for each timeperiod, expressed in units given by the power_units attribute","category":"page"},{"location":"SystemModel_HDF5_spec/#generators-group","page":".pras File Format","title":"generators group","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Information relating to the generators of the represented system is stored in the generators group inside the root group. This group should contain four datasets, one (named _core) providing core static data about each generator and three providing (potentially) time-varying data.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The _core dataset should be a vector / one-dimensional array storing instances of a compound datatype with the following fields (in order):","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"name: 128-byte ASCII string. Stores the unique name of each generator.\ncategory: 128-byte ASCII string. Stores the category of each generator.\nregion: 128-byte ASCII string. Stores the region of each generator.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each generator in the system corresponds to a single instance of the compound datatype, so the vector should have as many elements as there are generators in the system.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The generators group should also contain the following datasets describing (potentially) time-varying properties of the system generators:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"capacity, as unsigned 32-bit integers representing maximum available generation capacity for each generator in each timeperiod, expressed in units given by the power_units attribute\nfailureprobability, as 64-bit floats representing the probability the generator transitions from operational to forced outage during a given simulation timestep, for each generator in each timeperiod. Unitless.\nrepairprobability, as 64-bit floats representing the probability the generator transitions from forced outage to operational during a given simulation timestep, for each generator in each timeperiod. Unitless.","category":"page"},{"location":"SystemModel_HDF5_spec/#storages-group","page":".pras File Format","title":"storages group","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Information relating to the storage-only devices of the represented system is stored in the storages group inside the root group. This group should contain nine datasets, one (named _core) providing core static data about each region and eight providing (potentially) time-varying data.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The _core dataset should be a vector / one-dimensional array storing instances of a compound datatype with the following fields (in order):","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"name: 128-byte ASCII string. Stores the unique name of each generator.\ncategory: 128-byte ASCII string. Stores the category of each generator.\nregion: 128-byte ASCII string. Stores the region of each generator.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each generator in the system corresponds to a single instance of the compound datatype, so the vector should have as many elements as there are storages in the system.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The storages group should also contain the following datasets describing (potentially) time-varying properties of the system storage devices:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"chargecapacity, as unsigned 32-bit integers representing maximum available charging capacity for each storage unit in each timeperiod, expressed in units given by the power_units attribute\ndischargecapacity, as unsigned 32-bit integers representing maximum available discharging capacity for each storage unit in each timeperiod, expressed in units given by the power_units attribute\nenergycapacity, as unsigned 32-bit integers representing maximum available energy storage capacity for each storage unit in each timeperiod, expressed in units given by the energy_units attribute\nchargeefficiency, as 64-bit floats representing the ratio of power injected into the storage device's reservoir to power withdrawn from the grid, for each storage unit in each timeperiod. Unitless.\ndischargeefficiency, as 64-bit floats representing the ratio of power injected into the grid to power withdrawn from the storage device's reservoir, for each storage unit in each timeperiod. Unitless.\ncarryoverefficiency, as 64-bit floats representing the ratio of energy available in the storage device's reservoir at the beginning of one period to energy retained in the storage device's reservoir at the end of the previous period, for each storage unit in each timeperiod. Unitless.\nfailureprobability, as 64-bit floats representing the probability the unit transitions from operational to forced outage during a given simulation timestep, for each storage unit in each timeperiod. Unitless.\nrepairprobability, as 64-bit floats representing the probability the unit transitions from forced outage to operational during a given simulation timestep, for each storage unit in each timeperiod. Unitless.","category":"page"},{"location":"SystemModel_HDF5_spec/#generatorstorages-group","page":".pras File Format","title":"generatorstorages group","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Information relating to the combination generation-storage resources in the represented system is stored in the generatorstorages group inside the root group. This group should contain twelve datasets, one (named _core) providing core static data about each region and eleven providing (potentially) time-varying data.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The _core dataset should be a vector / one-dimensional array storing instances of a compound datatype with the following fields (in order):","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"name: 128-byte ASCII string. Stores the unique name of each generator-storage unit.\ncategory: 128-byte ASCII string. Stores the category of each generator-storage unit.\nregion: 128-byte ASCII string. Stores the region of each generator-storage unit.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each generator-storage unit in the system corresponds to a single instance of the compound datatype, so the vector should have as many elements as there are generator-storages units in the system.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The generatorstorages group should also contain the following datasets describing (potentially) time-varying properties of the system generator-storage devices:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"inflow, as unsigned 32-bit integers representing exogenous power inflow available to each generator-storage unit in each timeperiod, expressed in units given by the power_units attribute\ngridwithdrawalcapacity, as unsigned 32-bit integers representing maximum available capacity to withdraw power from the grid for each generator-storage unit in each timeperiod, expressed in units given by the power_units attribute\ngridinjectioncapacity, as unsigned 32-bit integers representing maximum available capacity to inject power to the grid for each generator-storage unit in each timeperiod, expressed in units given by the power_units attribute\nchargecapacity, as unsigned 32-bit integers representing maximum available charging capacity for each generator-storage unit in each timeperiod, expressed in units given by the power_units attribute\ndischargecapacity, as unsigned 32-bit integers representing maximum available discharging capacity for each generator-storage unit in each timeperiod, expressed in units given by the power_units attribute\nenergycapacity, as unsigned 32-bit integers representing maximum available energy storage capacity for each generator-storage unit in each timeperiod, expressed in units given by the energy_units attribute\nchargeefficiency, as 64-bit floats representing the ratio of power injected into the generator-storage device's reservoir to power withdrawn from the grid, for each generator-storage unit in each timeperiod. Unitless.\ndischargeefficiency, as 64-bit floats representing the ratio of power injected into the grid to power withdrawn from the generator-storage device's reservoir, for each generator-storage unit in each timeperiod. Unitless.\ncarryoverefficiency, as 64-bit floats representing the ratio of energy available in the generator-storage device's reservoir at the beginning of one period to energy retained in the device's reservoir at the end of the previous period, for each generator-storage unit in each timeperiod. Unitless.\nfailureprobability, as 64-bit floats representing the probability the unit transitions from operational to forced outage during a given simulation timestep, for each generator-storage unit in each timeperiod. Unitless.\nrepairprobability, as 64-bit floats representing the probability the unit transitions from forced outage to operational during a given simulation timestep, for each generator-storage unit in each timeperiod. Unitless.","category":"page"},{"location":"SystemModel_HDF5_spec/#interfaces-group","page":".pras File Format","title":"interfaces group","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Information relating to transmission interfaces between regions of the represented system is stored in the interfaces group inside the root group. This group should contain three datasets, one (named _core) providing core static data about each interface and two providing (potentially) time-varying data.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The _core dataset should be a one-dimensional array storing instances of a compound datatype with the following fields (in order):","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"region_from: 128-byte ASCII string. Stores the name of the first of the two regions connected by the interface.\nregion_to: 128-byte ASCII string. Stores the name of the second of the two regions connected by the interface.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each interface in the system corresponds to a single instance of the compound datatype, so the array should have as many elements as there are interfaces in the system.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The interfaces group should contain the following datasets describing (potentially) time-varying properties of the system regions:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"forwardcapacity, as unsigned 32-bit integers representing the maximum possible total power transfer from region_from to region_to, for each interface in each time period\nbackwardcapacity, as unsigned 32-bit integers representing the maximum possible total power transfer from region_to to region_from, for each interface in each time period","category":"page"},{"location":"SystemModel_HDF5_spec/#lines-group","page":".pras File Format","title":"lines group","text":"","category":"section"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Information relating to individual transmission lines between regions of the represented system is stored in the lines group inside the root group. This group should contain five datasets, one (named _core) providing core static data about each interface and four providing (potentially) time-varying data.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The _core dataset should be a one-dimensional array storing instances of a compound datatype with the following fields (in order):","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"name: 128-byte ASCII string. Stores the unique name of the line.\ncategory: 128-byte ASCII string. Stores the assigned category of the line.\nregion_from: 128-byte ASCII string. Stores the name of the first of the two regions connected by the line.\nregion_to: 128-byte ASCII string. Stores the name of the second of the two regions connected by the line.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"Each line in the system corresponds to a single instance of the compound datatype, so the array should have as many elements as there are lines in the system.","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"The lines group should contain the following datasets describing (potentially) time-varying properties of the system regions:","category":"page"},{"location":"SystemModel_HDF5_spec/","page":".pras File Format","title":".pras File Format","text":"forwardcapacity, as unsigned 32-bit integers representing maximum available power transfer capacity from region_from to region_to along the line, for each line in each time period\nbackwardcapacity, as unsigned 32-bit integers representing maximum available power transfer capacity from region_to to region_from along the line, for each line in each time period\nfailureprobability, as 64-bit floats representing the probability the line transitions from operational to forced outage during a given simulation timestep, for each line in each timeperiod. Unitless.\nrepairprobability, as 64-bit floats representing the probability the line transitions from forced outage to operational during a given simulation timestep, for each line in each timeperiod. Unitless.","category":"page"},{"location":"resourceadequacy/#resourceadequacy","page":"Resource Adequacy","title":"Resource Adequacy Background","text":"","category":"section"},{"location":"resourceadequacy/","page":"Resource Adequacy","title":"Resource Adequacy","text":"An electrical power system is considered resource adequate if it has procured sufficient resources (including supply, transmission, and responsive demand) such that it runs a sufficiently low risk of invoking emergency measures (such as involuntary load shedding) due to resource unavailability or deliverability constraints. Resource adequacy is a necessary (but not sufficient) condition for overall power system reliability, which considers a broader set of system constraints including operational flexibility and the stability of system voltages and frequency.","category":"page"},{"location":"resourceadequacy/","page":"Resource Adequacy","title":"Resource Adequacy","text":"Probabilistic resource adequacy assessment is the process by which resource shortfall risk is quantified. It involves mapping quantified uncertainties in system operating conditions (primarily forced outages of generators and lines) into probability distributions for operating outcomes of interest by simulating system operations under different probabilistically weighted scenarios. The nature of those simulations varies between models, and can range from simple snapshot comparisons of peak demand versus available supply, through to chronological simulations of system dispatch and power flow over the full operating horizon.","category":"page"},{"location":"resourceadequacy/","page":"Resource Adequacy","title":"Resource Adequacy","text":"The resulting outcomes can then be used to calculate industry-standard probabilistic risk metrics [1].","category":"page"},{"location":"resourceadequacy/","page":"Resource Adequacy","title":"Resource Adequacy","text":"Expected Unserved Energy (EUE) is the expected (average) total energy shortfall over the study period. It may be expressed in energy units (e.g. GWh per year) or normalized against the system's total energy demand and expressed as a fraction (normalized EUE, or NEUE, expressed as a percentage or in parts-per-million, ppm).","category":"page"},{"location":"resourceadequacy/","page":"Resource Adequacy","title":"Resource Adequacy","text":"Loss-of-Load Expectation (LOLE) is the expected (average) count of periods experiencing shortfall over the study period. It is expressed in terms of event-periods (e.g. event-hours per year, event-days per year). When reported in terms of event-hours, LOLE is sometimes referred to as LOLH (loss-of-load hours).","category":"page"},{"location":"resourceadequacy/","page":"Resource Adequacy","title":"Resource Adequacy","text":"While a system's shortfall risk can never be eliminated entirely, if these risk metrics are assessed to be lower than some predetermined threshold, the system is considered resource adequate.","category":"page"},{"location":"resourceadequacy/","page":"Resource Adequacy","title":"Resource Adequacy","text":"It can sometimes also be useful to express the average and/or incremental contribution of a particular resource to overall system adequacy in terms of capacity. This quantity (either in units of power, or as a fraction of the unit's nameplate capacity) is known as the capacity credit (sometimes called capacity value) of the resource. While many different methods are used to estimate the capacity credit of a resource, the most rigorous approaches generally involve assessing the change in probabilistic system adequacy associated with adding or removing the resource from the system. As a result, capacity credit calculation is often closely associated with probabilistic resource adequacy assessment.","category":"page"},{"location":"resourceadequacy/#References","page":"Resource Adequacy","title":"References","text":"","category":"section"},{"location":"resourceadequacy/","page":"Resource Adequacy","title":"Resource Adequacy","text":"de Mijolla, G., Bello, M., Danti Lopez, I., Entriken, R., Hytowitz, R.,   Lannoye, E., Ranola, J.A., Roark, J., Tuohy, A., & Wang, Q. (2022).   Resource adequacy for a decarbonized future: A summary of existing and   proposed resource adequacy metrics.   Tech. Rep. 3002023230, Electric Power Research Institute (EPRI).","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/#[0.8.0],-2025-October","page":"Changelog","title":"[0.8.0], 2025 - October","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add a demand response component which can model shift and shed type DR devices\nAdd SystemModel attributes\nEnable pretty printing of different PRAS component information\nEnable auto-generated documentation website with detailed tutorials and walk-throughs","category":"page"},{"location":"changelog/#[0.7],-2024-December","page":"Changelog","title":"[0.7], 2024 - December","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"PRAS codebase refactored as a monorepo, and subpackages PRAS.jl, PRASCore.jl, PRASFiles.jl, and PRASCapacityCredits.jl available through the Julia General registries.\nRemoved Convolution and NonSequentialMonteCarlo simulation capabilities to simplify codebase.\nBump Julia version required to v1.10 \nAdd results serialization capability for ShortfallResults","category":"page"},{"location":"changelog/#[0.6],-2021-May","page":"Changelog","title":"[0.6], 2021 - May","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Major updates to the results interface, including for capacity credit and SequentialMonteCarlo.\nRefactored and simplified metric types.\nAdded and tested new modular result specifications.\nUpdated capacity credit calculations and de-duplicated specification keyword defaults.\nAdded tests for savemodel and support for exporting .pras files.\nReplaced Travis CI with GitHub Actions for continuous integration.\nImproved compatibility with HDF5.jl and ensured non-negative storage state of charge.\nEnforced interface-level limits and forced outages for storage and generator-storage.\nRemoved unused test files and updated the README with a code coverage badge.","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"This version is availabe at the NREL Julia registries or through source code available  in the master branch of the PRAS github  repository. Documentation for this version is available here.","category":"page"},{"location":"changelog/#[0.5],-2020-November","page":"Changelog","title":"[0.5], 2020 - November","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Major refactor of simulation specs and result types.\nAdded support for sequential and nonsequential simulation methods.\nImproved modularity of result specifications and metrics.\nAdded support for capacity credit and spatiotemporal result specs.\nImproved documentation and test coverage.","category":"page"},{"location":"changelog/#[0.4],-2019-July","page":"Changelog","title":"[0.4], 2019 - July","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Added support for storage and generator-storage modeling.\nImproved network flow and copperplate simulation methods.\nAdded new result types and improved performance.\nRefactored codebase for better modularity and maintainability.","category":"page"},{"location":"changelog/#[0.3],-2019-April","page":"Changelog","title":"[0.3], 2019 - April","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Added support for network result types and transmission modeling.\nImproved simulation performance and result extraction.\nAdded new tests and documentation.","category":"page"},{"location":"changelog/#[0.2],-2019-August","page":"Changelog","title":"[0.2], 2019 - August","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Added tests and improved SystemModel constructor.\nImproved compatibility with Julia 1.0+.\nAdded Travis CI integration and coverage reporting.","category":"page"},{"location":"changelog/#[0.1],-2018-March","page":"Changelog","title":"[0.1], 2018 - March","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Initial public release of PRAS.\nBasic resource adequacy simulation and result extraction.\nInitial documentation and test coverage.","category":"page"},{"location":"examples/pras_walkthrough/#pras_walkthrough","page":"PRAS 101 Walkthrough","title":"PRAS Walkthrough","text":"","category":"section"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"This is a complete example of running a PRAS assessment, using the RTS-GMLC system","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Load the PRAS package and other tools necessary for analyses","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"using PRAS\nusing Plots\nusing DataFrames\nusing Printf","category":"page"},{"location":"examples/pras_walkthrough/#explore_systemmodel","page":"PRAS 101 Walkthrough","title":"Read and Explore a SystemModel","text":"","category":"section"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"You can load in a system model from a .pras file if you have one like so:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"sys = SystemModel(\"mysystem.pras\")","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"For the purposes of this example, we'll just use the built-in RTS-GMLC model.","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"sys = PRAS.rts_gmlc();\nnothing #hide","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We see some information about the system by just typing its name (or rather the variable that holds it):","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"sys","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We retrieve the parameters of the system using the get_params function and use this for the plots below to ensure we have correct units:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"(timesteps,periodlen,periodunit,powerunit,energyunit) = get_params(rts_gmlc())","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"This system has 3 regions, with multiple Generators, one GenerationStorage in region \"2\" and one Storage in region \"3\". We can see regional information by indexing the system by region name:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"sys[\"2\"]","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We can visualize a time series of the regional load in region \"2\":","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"region_2_load = sys.regions.load[sys[\"2\"].index,:]\nplot(sys.timestamps, region_2_load,\n     xlabel=\"Time\", ylabel=\"Region 2 load ($(powerunit))\",\n     legend=false)","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We can find more information about all the Generators in the system by retriving the generators in the SystemModel:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"system_generators = sys.generators","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"This returns an object of the asset type Generators and we can retrieve capacities of all generators in the system, which returns a Matrix with the shape (number of generators) x (number of timesteps):","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"system_generators.capacity","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We can visualize a time series of the total system capacity (sum over individual generators' capacity at each time step)","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"plot(sys.timestamps, sum(system_generators.capacity, dims=1)',\n     xlabel=\"Time\", ylabel=\"Total system capacity (MW)\", legend=false)","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Or, by category of generators:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"category_indices = Dict([cat => findall(==(cat), system_generators.categories)\n                    for cat in unique(system_generators.categories)]);\ncapacity_matrix = Vector{Vector{Int}}();\nfor (category,indices) in category_indices\n    push!(capacity_matrix, sum(system_generators.capacity[indices, :], dims=1)[1,:])\nend\nareaplot(sys.timestamps, hcat(capacity_matrix...),\n        label=permutedims(collect(keys(category_indices))),\n        xlabel=\"Time\", ylabel=\"Total system capacity (MW)\")","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Similarly we can also retrieve all the Storages in the system and GenerationStorages in the system using sys.storages and sys.generatorstorages, respectively.","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"To retrieve the assets in a particular region, we can index by the region name and asset type (Generators here):","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"region_2_generators = sys[\"2\", Generators]","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We get the storage device in region \"3\" like so:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"region_3_storage = sys[\"3\", Storages]","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"and the generation-storage device in region \"2\" like so:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"region_2_genstorage = sys[\"2\", GeneratorStorages]","category":"page"},{"location":"examples/pras_walkthrough/#Run-a-Sequential-Monte-Carlo-Simulation","page":"PRAS 101 Walkthrough","title":"Run a Sequential Monte Carlo Simulation","text":"","category":"section"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We can run a Sequential Monte Carlo simulation on this system using the assess function. Here we will also use four different result specifications:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"shortfall, surplus, utilization, storage = assess(\n    sys, SequentialMonteCarlo(samples=100, seed=1),\n    Shortfall(), Surplus(), Utilization(), StorageEnergy());\nnothing #hide","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Start by checking the overall system adequacy:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"lole = LOLE(shortfall); # event-hours per year\neue = EUE(shortfall); # unserved energy per year\nprintln(\"System $(lole), $(eue)\")","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Given we use only 100 samples and the RTS-GMLC system is quite reliable, we see a system which is reliable, with LOLE and EUE both near zero. For the purposes of this example, let's increase the system load homogenously by 700MW in every hour and region, and re-run the assessment.","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"sys.regions.load .+= 700.0\nshortfall, surplus, utilization, storage = assess(\n    sys, SequentialMonteCarlo(samples=100, seed=1),\n    Shortfall(), Surplus(), Utilization(), StorageEnergy());\nlole = LOLE(shortfall); # event-hours per year\neue = EUE(shortfall); # unserved energy per year\nneue = NEUE(shortfall); # unserved energy per year\nprintln(\"System $(lole), $(eue), $(neue)\")","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Now we see a system which is slightly unreliable with a normalized expected unserved energy (NEUE) of close to 470 parts per million of total load.","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We can now look at the hourly loss-of-load expectation (LOLE) to see when when shortfalls are occurring. LOLE.(shortfall, many_hours) is Julia shorthand for calling LOLE  on every timestep in the collection many_hours","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"lolps = LOLE.(shortfall, sys.timestamps)","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Here results are in terms of event-hours per hour, which is equivalent to the loss-of-load probability (LOLP) for each hour. The LOLE object is shown as mean ± standard error. We are mostly interested in the mean here, we can retrieve this using val.(lolps) and visualize this:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"plot(sys.timestamps, val.(lolps),\n     xlabel=\"Time\", ylabel=\"Hourly LOLE (event-hours/hour)\", legend=false)","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We see the shortfall is concentrated in a few hours and there are many hours with LOLE = 1, which means that hour had a shortfall in every Monte Carlo sample.","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We can find the regional NEUE for the entire simulation period, and obtain it in as a DataFrame for easier viewing:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"regional_eue = DataFrame([(Region=reg_name, NEUE=val(NEUE(shortfall, reg_name)))\n                          for reg_name in sys.regions.names],\n                         )","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"So, region \"1\" has the highest overall NEUE, and has a higher load normalized shortfall","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We may be interested in the EUE in the hour with highest LOLE","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"max_lole_ts = sys.timestamps[findfirst(val.(lolps).==1)];\nprintln(\"Hour with first LOLE of 1.0: \", max_lole_ts)","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"And we can find the unserved energy by region in that hour:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"unserved_by_region = EUE.(shortfall, sys.regions.names, max_lole_ts)","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"which returns a Vector of EUE values for each region.","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Region 2 has highest EUE in that hour, and we can look at the utilization of interfaces into that region in that period:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"utilization_str = join([@sprintf(\"Interface between regions 1 and 2 utilization: %0.2f\",\n                            utilization[\"1\" => \"2\", max_lole_ts][1]),\n                    @sprintf(\"Interface between regions 3 and 2 utilization: %0.2f\",\n                            utilization[\"3\" => \"2\", max_lole_ts][1]),\n                    @sprintf(\"Interface between regions 1 and 3 utilization: %0.2f\",\n                            utilization[\"1\" => \"3\", max_lole_ts][1])], \"\\n\");\nprintln(utilization_str)","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"We see that the interfaces are not fully utilized, which means there is no excess generation in the system that could be transferred into region \"2\" and we can confirm this by looking at the surplus generation in each region","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"println(\"Surplus in\")\n@printf(\"  region 1: %0.2f\\n\",surplus[\"1\",max_lole_ts][1])\n@printf(\"  region 2: %0.2f\\n\",surplus[\"2\",max_lole_ts][1])\n@printf(\"  region 3: %0.2f\\n\",surplus[\"3\",max_lole_ts][1])","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Is local storage another alternative for region 3? One can check on the average state-of-charge of the existing battery in region \"3\", both in the hour before and during the problematic period:","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"@printf(\"Storage energy T-1: %0.2f\\n\",storage[\"313_STORAGE_1\", max_lole_ts-Hour(1)][1])\n@printf(\"Storage energy T: %0.2f\\n\",storage[\"313_STORAGE_1\", max_lole_ts][1])","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"It may be that the battery is on average charged going in to the event, and perhaps retains some energy during the event, even as load is being dropped. The device's ability to mitigate the shortfall must then be limited only by its discharge capacity, so increasing the regions storage capacity by adding more storage devices may help mitigate some shortfall.","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"Note that if the event was less consistent, this analysis could also have been performed on the subset of samples in which the event was observed, using the ShortfallSamples, UtilizationSamples, and StorageEnergySamples result specifications instead.","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"","category":"page"},{"location":"examples/pras_walkthrough/","page":"PRAS 101 Walkthrough","title":"PRAS 101 Walkthrough","text":"This page was generated using Literate.jl.","category":"page"},{"location":"PRAS/simulations/#simulations","page":"Simulation Specifications","title":"Simulation Specifications","text":"","category":"section"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"There are many different simplifying assumptions that can be made when simulating power system operations for the purpose of studying resource adequacy. The level of simplification a modeller is willing to accept will depend on the goals of the study and the computational resources available to carry out the modelling exercise.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"PRAS is referred to as a \"suite\" because of its inclusion of multiple power system operations models of varying fidelity and computational complexity. Each PRAS analysis (a single invocation of PRAS' assess function) is associated with exactly one of these operational models, or \"simulation specifications\". A simulation specification encodes a particular set of assumptions and simplifications that will be used when simulating operations in order to assess the resource adequacy of the study system.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"The current version of PRAS defines the Sequential Monte Carlo specification, with additional user-defined specifications possible (see Custom Simulation Specifications). The remainder of this section describes the methods and underlying assumptions of each of these built-in simulation specifications.","category":"page"},{"location":"PRAS/simulations/#Sequential-Monte-Carlo","page":"Simulation Specifications","title":"Sequential Monte Carlo","text":"","category":"section"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"The Sequential Monte Carlo method simulates the chronological evolution of the system, tracking individual unit-level outage states and the state of charge of energy-limited resources. While it is the most computationally intensive simulation method provided in PRAS, it remains much simpler (and therefore runs much faster) than a production cost model.","category":"page"},{"location":"PRAS/simulations/#Theory-and-Assumptions","page":"Simulation Specifications","title":"Theory and Assumptions","text":"","category":"section"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"The Sequential Monte Carlo method simulates unit-level outages using a two-state Markov model. In each time period, the availability state of each generator, storage, generator-storage, and line either changes or remains the same, at random, based on the unit's provided state transition probabilities. The capacities from each available generator (or line) in a given time period are then added together to determine the total available generating (transfer) capacity for a region (interface). Storage and generator-storage units are similarly enabled or disabled based on their availability states.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"Each set of sampled parameters is used to formulate the \"pipe-and-bubble\" network flow problem shown below, in which local demand in each region is satisfied (or not) using a combination of local generation, imported power, and unserved energy. Regions with surplus capacity can export that power to their neighbours if transmission limits allow, with a small transfer penalty applied to prevent loop flows. Any demand that cannot be supplied under the randomly drawn generation and transmission limits is considered unserved.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"<figure>\n<img src=\"../../images/networkflow.svg\" alt=\"Example three-region network flow problem to be solved\n        by the Non-Sequential Monte Carlo simulation specification. Any\n        load that cannot be served within the sampled generation\n        and transmission constraints goes unserved.\" style=\"max-width:2000px;  width:50%;\"/>\n<figcaption> Example three-region network flow problem to be solved\n        by the Non-Sequential Monte Carlo simulation specification. Any\n        load that cannot be served within the sampled generation\n        and transmission constraints goes unserved </figcaption>\n</figure>","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"The Sequential Monte Carlo method is unique in its ability to represent energy-limited resources (storages and generator-storages). These resources are dispatched conservatively so as to approximately minimize unserved energy over the full simulation horizon, charging from the grid whenever surplus generating capacity is available, and discharging only when needed to avoid or mitigate unserved energy. Charging and discharging is coordinated between resources using the time-to-go priority described in Evans et al. (2019): resources that would be able to discharge the longest at their maximum rate are discharged first, and resources that would take the longest time to charge at their maximum charge rate are charged first. Cross-charging (discharging one resource in order to charge another) is not permitted.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"In Sequential Monte Carlo simulations, one \"sample\" involves chronological simulation of the system over the full operating horizon. Unserved energy results for each hour and the overall horizon are recorded before restarting the simulation and repeating the process with new random outage draws. Once all samples have been completed, hourly and overall system risk metrics can be calculated.","category":"page"},{"location":"PRAS/simulations/#Usage","page":"Simulation Specifications","title":"Usage","text":"","category":"section"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"A sequential Monte Carlo resource adequacy assessment is invoked by calling PRAS' assess method in Julia, with SequentialMonteCarlo() as the simulation specification argument:","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"assess(sys, SequentialMonteCarlo(), Shortfall())","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"The SequentialMonteCarlo() specification accepts several optional keyword arguments, which can be provided in any order:","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"samples: A positive integer value defaulting to 10000. It defines the number of samples (replications) to be used in the Monte Carlo simulation process.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"seed: An integer defaulting to a random value. It defines the seed to beused for random number generation when sampling generator and line outage state transitions.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"threaded: A boolean value defaulting to true. If true, PRAS will parallelize simulations across the number of threads available to Julia. Setting this to false can help with debugging if an assessment is hanging.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"verbose: A boolean value defaulting to false. If true, PRAS will output informative text describing the progress of the assessment.","category":"page"},{"location":"PRAS/simulations/#References","page":"Simulation Specifications","title":"References","text":"","category":"section"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"Billinton, R. (1970). Power System Reliability Evaluation. Gordon and Breach.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"Evans, M. P., Tindemans, S. H., & Angeli, D. (2019). Minimizing Unserved Energy Using Heterogeneous Storage Units. IEEE Transactions on Power Systems, 34(5), 3647-3656.","category":"page"},{"location":"PRAS/simulations/","page":"Simulation Specifications","title":"Simulation Specifications","text":"Haringa, G. E., Jordan, G. A., & Garver, L. L. (1991). Application of Monte Carlo simulation to multi-area reliability evaluations. IEEE Computer Applications in Power, 4(1), 21-25.","category":"page"},{"location":"PRASFiles/api/#PRASFiles.read_attrs-Tuple{HDF5.File}","page":"PRASFiles","title":"PRASFiles.read_attrs","text":"Reads additional user defined metadata from the file containing the PRAS system, Input here is filehandle.\n\n\n\n\n\n","category":"method"},{"location":"PRASFiles/api/#PRASFiles.read_attrs-Tuple{String}","page":"PRASFiles","title":"PRASFiles.read_attrs","text":"Reads user defined metadata from the file containing the PRAS system.\n\n\n\n\n\n","category":"method"},{"location":"PRASFiles/api/#PRASFiles.savemodel-Tuple{SystemModel, String}","page":"PRASFiles","title":"PRASFiles.savemodel","text":"savemodel(sys::SystemModel, outfile::String) -> nothing\n\nExport a PRAS SystemModel sys as a .pras file, saved to outfile\n\n\n\n\n\n","category":"method"},{"location":"PRASFiles/api/#PRASFiles.saveshortfall-Tuple{PRASCore.Results.AbstractShortfallResult, SystemModel, String}","page":"PRASFiles","title":"PRASFiles.saveshortfall","text":"saveshortfall(\n    shortfall::AbstractShortfallResult,\n    pras_sys::SystemModel,\n    outfile::String,\n)\n\nSave ShortfallResult or ShortfallSample Result in JSON format. Only aggregate system and region level results are exported. Sample level results are not exported..\n\nArguments\n\n- `shortfall::AbstractShortfallResult`: ShortfallResult (or) ShortfallSamplesResult\n- `pras_sys::SystemModel`: PRAS SystemModel\n- `outfile::String`: Location to save the ShortfallResult\n\nReturns\n\nLocation where ShortfallResult (or) ShortfallSamplesResult is exported in JSON format.\n\n\n\n\n\n","category":"method"},{"location":"extending/#extending","page":"Extending PRAS","title":"Extending PRAS","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"PRAS provides opportunties for users to non-invasively build on its general simulation framework by redefining how simulations are executed, augmenting how results are reported, or both. This allows for customized analyses without requiring the user to modify code in the main PRAS package or implement their own model from scratch.","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"To implement custom functionality, a user needs to define specific Julia data structures as well as implement function methods that operate on those structures. Julia's multiple dispatch functionality can then identify and use these newly defined capabilities when the assess function is invoked appropriately.","category":"page"},{"location":"extending/#customsimspec","page":"Extending PRAS","title":"Custom Simulation Specifications","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"Custom simulation specifications allow for redefining how PRAS models system operations. In addition to the data structures and methods listed here, defining a new simulation specification also requires defining the appropriate simulation-result interactions (see Simulation-Result Interfaces).","category":"page"},{"location":"extending/#New-Data-Structure-Requirements","page":"Extending PRAS","title":"New Data Structure Requirements","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"The following new data structure (struct / type) should be defined in Julia:","category":"page"},{"location":"extending/#Simulation-Specification","page":"Extending PRAS","title":"Simulation Specification","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"The main type representing the new simulation specification. It should be a subtype of the SimulationSpec abstract type and can contain fields that store simulation parameters (such as the number of Monte Carlo samples to run or the random number generation seed to use). For example:","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"struct MyCustomSimSpec <: SimulationSpec\n    nsamples::UInt64\n    seed::UInt64\nend","category":"page"},{"location":"extending/#New-Method-Requirements","page":"Extending PRAS","title":"New Method Requirements","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"The following new function method should be defined in Julia:","category":"page"},{"location":"extending/#assess","page":"Extending PRAS","title":"assess","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"The method to be invoked when the assess function is called with the previously defined simulation specification. By convention, the method should take a SystemModel as the first argument, followed by a specific subtype of SimulationSpec, followed by one or more unspecified subtypes of ResultSpec. For example (using the MyCustomSimSpec type defined above):","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"function PRAS.assess(\n    sys::SystemModel, simspec::MyCustomSimSpec, resultspecs::ResultSpec...)\n\n    # Implement the simulation logic for MyCustomSimSpec here\n\n    # This will include simulation-result interaction calls to result\n    # recording methods, which will need to be implemented by any result \n    # specification wanting to be compatible with MyCustomSimSpec\n\nend","category":"page"},{"location":"extending/#Custom-Result-Specifications","page":"Extending PRAS","title":"Custom Result Specifications","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"Custom result specifications allow for saving out additional information that may be generated during simulations of system operations. In addition to the data structures and methods listed here, defining a new result specification also requires defining the appropriate simulation-result interactions (see Simulation-Result Interfaces).","category":"page"},{"location":"extending/#New-Data-Structure-Requirements-2","page":"Extending PRAS","title":"New Data Structure Requirements","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"The following new data structures (structs / types) should be defined in Julia:","category":"page"},{"location":"extending/#Result-Specification","page":"Extending PRAS","title":"Result Specification","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"The main type representing the result specification. It should be a subtype of the ResultSpec abstract type and can contain fields that store result parameters (although this is usually not necessary). For example:","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"struct MyCustomResultSpec <: ResultSpec\nend","category":"page"},{"location":"extending/#Result","page":"Extending PRAS","title":"Result","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"The type of the data that is returned at the end of an assessment and stores any information to be reported to the end-user. It should be a subtype of the Result abstract type and should contain fields that store the desired results. For example:","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"struct MyCustomResult <: Result\n    myoutput1::Float64\n    myoutput2::Vector{Bool}\nend","category":"page"},{"location":"extending/#New-Method-Requirements-2","page":"Extending PRAS","title":"New Method Requirements","text":"","category":"section"},{"location":"extending/#Indexing","page":"Extending PRAS","title":"Indexing","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"Result data should support index lookups to report overall results or values for specific time periods, regions, interfaces, units, etc. The specifics of how the result data is indexed will depend on the nature of the result type, but will likely involve implementing one of more of the following methods (here we assume the new result type is MyCustomResult):","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"Base.getindex(result::MyCustomResult)\nBase.getindex(result::MyCustomResult, region_or_unit::String)\nBase.getindex(result::MyCustomResult, interface::Pair{String,String})\nBase.getindex(result::MyCustomResult, period::ZonedDateTime)\nBase.getindex(result::MyCustomResult,\n              region_or_unit::String, period::ZonedDateTime)\nBase.getindex(result::MyCustomResult,\n              interface::Pair{String,String}, period::ZonedDateTime)","category":"page"},{"location":"extending/#Risk-Metrics","page":"Extending PRAS","title":"Risk Metrics","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"If the result includes information that can be used to calculate resource adequacy metrics, some or all of following new function methods should be defined (here we assume the new result type is MyCustomResult):","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"PRAS.LOLE(result::MyCustomResult)\nPRAS.LOLE(result::MyCustomResult, region::String)\nPRAS.LOLE(result::MyCustomResult, period::ZonedDateTime)\nPRAS.LOLE(result::MyCustomResult, region::String, period::ZonedDateTime)\n\nPRAS.EUE(result::MyCustomResult)\nPRAS.EUE(result::MyCustomResult, region::String)\nPRAS.EUE(result::MyCustomResult, period::ZonedDateTime)\nPRAS.EUE(result::MyCustomResult, region::String, period::ZonedDateTime)","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"If desired, new result specifications may define additional result-specific accessor methods as well.","category":"page"},{"location":"extending/#Simulation-Result-Interfaces","page":"Extending PRAS","title":"Simulation-Result Interfaces","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"Result specifications need a way to map information produced by a simulation to outcomes of interest. The specifics of how this is implemented will vary between simulation specifications, but in general, a specific assess method will invoke another method that records abstract results. This recording method will then be implemented by all of the concrete result specifications wishing to support that simulation specification. A very simplified example of this pattern is:","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"function assess(\n    sys::SystemModel, simspec::MyCustomSimSpec, resultspecs::ResultSpec...)\n\n    # Implement the simulation logic for MyCustomSimSpec here,\n    # and collect full results\n    simulationdata = ...\n\n    # Store requested results\n    results = ()\n    for resultspec in resultspecs\n        results = (results..., record(simspec, resultspec, simulationdata))\n    end\n\n    return results\n\nend\n\nfunction record(\n    simspec::MyCustomSimSpec, resultspec::Shortfall, simulationdata)\n    # Map simulationdata to shortfall results here\n    return ShortfallResult(...)\nend\n\nfunction record(\n    simspec::MyCustomSimSpec, resultspec::Surplus, simulationdata)\n    # Map simulationdata to surplus results here\n    return SurplusResult(...)\nend\n\nfunction record(\n    simspec::MyCustomSimSpec, resultspec::MyCustomResultSpec, simulationdata)\n    # Map simulationdata to my custom results here\n    return MyCustomResult(...)\nend","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"By implementing the types and methods described here, a new result specification can be made compatible with these existing simulation types. In each case, we assume the MyResultSpec <: ResultSpec and MyResult <: Result types have been previously defined.","category":"page"},{"location":"extending/#Result-Accumulator","page":"Extending PRAS","title":"Result Accumulator","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"A sequential Monte Carlo result accumulator incrementally collects relevant intermediate outcomes as chronological simulations under different random samples are performed.","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"# Define the accumulator structure\nstruct SMCMyResultAccumulator <: ResultAccumulator{SequentialMonteCarlo,MyResultSpec}\n    # fields for holding intermediate data go here\nend\n\n# Help PRAS know which accumulator type to expect before one's created\nPRAS.ResourceAdequacy.accumulatortype(::SequentialMonteCarlo, ::MyResultSpec) =\n    SMCMyResultAccumulator\n\n# Initialize a new accumulator\nfunction PRAS.ResourceAdequacy.accumulator(\n    sys::SystemModel, simspec::SequentialMonteCarlo, resultspec::MyResultSpec)\n    return SMCMyResultAccumulator(...)\nend","category":"page"},{"location":"extending/#record!","page":"Extending PRAS","title":"record!","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"Once system operations in a given time period t have been simulated within a given chronological sample sequence s, the record! method extracts outcomes of interest from one or both of the system's current state and the solution to the period's dispatch problem prob. These results are used to update the accumulator acc in-place.","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"PRAS.ResourceAdequacy.record!(\n    acc::SMCMyResultAccumulator, sys::SystemModel, state::SystemState,\n    prob::DispatchProblem, s::Int, t::Int)","category":"page"},{"location":"extending/#reset!","page":"Extending PRAS","title":"reset!","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"At the end of each chronological sequence of time periods s, the reset! method updates the accumulator acc in-place to finalize recording of any results requiring information from multiple periods, and prepare the accumulator to start receiving values from a new chronological simulation sequence.","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"PRAS.ResourceAdequacy.reset!(acc::SMCMyResultAccumulator, s::Int)\n\n# Often no action is required here,\n# so a simple one-line implementation is possible\nPRAS.ResourceAdequacy.reset!(acc::SMCMyResultAccumulator, s::Int) = nothing","category":"page"},{"location":"extending/#merge!","page":"Extending PRAS","title":"merge!","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"For multithreaded assessments PRAS creates one accumulator per worker thread (parallel task) and merges each thread's accumulator information togther once work is completed. merge! defines how an accumulator a should be updated in-place to incorporate the results obtained by another accumulator b.","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"PRAS.ResourceAdequacy.merge!(\n    a::SMCMyResultAccumulator, b::SMCMyResultAccumulator)","category":"page"},{"location":"extending/#finalize!","page":"Extending PRAS","title":"finalize!","text":"","category":"section"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"Once all of the thread accumulators have been merged down to a single accumulator reflecting results from all of the threads, this final accumulator acc is mapped to the final result output through a finalize method.","category":"page"},{"location":"extending/","page":"Extending PRAS","title":"Extending PRAS","text":"function PRAS.ResourceAdequacy.finalize(\n    acc::SMCMyResultAccumulator, sys::SystemModel)\n\n    return MyResult(...)\n\nend","category":"page"},{"location":"quickstart/#quickstart","page":"Quick Start","title":"Getting Started with PRAS","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Once you have PRAS installed, this page provides a brief overview to help you start running PRAS quickly. A more detailed example with analyses is available at PRAS walkthrough.","category":"page"},{"location":"quickstart/#Parallel-Processing","page":"Quick Start","title":"Parallel Processing","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"PRAS uses multi-threading, so be sure to set the environment variable controlling the number of threads available to Julia (36 in this Bash example, which is a good choice for NREL Eagle nodes - on a laptop you would probably only want 4 or so) before running scripts or launching the REPL:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"export JULIA_NUM_THREADS=36","category":"page"},{"location":"quickstart/#Power-System-Data","page":"Quick Start","title":"Power System Data","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The recommended way to store and retrieve PRAS system data is in an HDF5 file that conforms to the PRAS system data format. Once your system is represented in that format you can load it into PRAS with:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using PRAS\nsys = SystemModel(\"filepath/to/systemdata.pras\")","category":"page"},{"location":"quickstart/#Resource-Adequacy-Assessment","page":"Quick Start","title":"Resource Adequacy Assessment","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"PRAS functionality is distributed across groups of modular specifications that can be mixed, extended, or replaced to support the needs of a particular analysis. When assessing reliability or capacity value, one can define the specs to be used while passing along any associated parameters or options.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The categories of specifications are:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Simulation Specifications: How should power system operations be simulated? You can use the SequentialMonteCarlo specification.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Result Specifications: What kind and level of detail of results should be saved out during simulations? Options include Shortfall, Surplus, interface Flow, StorageEnergy, and GeneratorStorageEnergy. See Result specification for more details.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Capacity Credit Specifications: If performing a capacity credit calculation, which method should be used? Options are EFC and ELCC.","category":"page"},{"location":"quickstart/#Running-an-analysis","page":"Quick Start","title":"Running an analysis","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Analysis centers around the assess method with different arguments passed depending on the desired analysis to run. For example, if you instead want to run a simulation that considers energy-limited resources and transmission constraints, using 100,000 Monte Carlo samples, the method call becomes:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"assess(mysystemmodel, SequentialMonteCarlo(samples=100_000), Shortfall())","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"You can request multiple kinds of result from a single assessment:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"assess(mysystemmodel, SequentialMonteCarlo(samples=100_000), Shortfall(), Flow())","category":"page"},{"location":"quickstart/#Querying-Results","page":"Quick Start","title":"Querying Results","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Each result type requested returns a seperate result object. These objects can then be queried using indexing syntax to extract values of interest.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"shortfalls, flows =\n    assess(mysystemmodel, SequentialMonteCarlo(samples=100_000), Shortfall(), Flow())\n\nflows[\"Region A\" => \"Region B\"]","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The full PRAS documentation provides more details on how different result object types can be indexed.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Because the main results of interest from resource adequacy assessments are probabilistic risk metrics (i.e. EUE and LOLE), Shortfall result objects define some additional methods: a particular risk metric can be obtained by calling that metric's constructor with the Shortfall result object. For example, to obtain the system-wide LOLE and EUE over the simulation period:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"lole = LOLE(shortfalls)\neue = EUE(shortfalls)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Single-period metrics can also be extracted. For example, to get system-wide EUE for April 27th, 2024 at 1pm EST:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"period_eue = EUE(shortfalls, ZonedDateTime(2024, 4, 27, 13, tz\"EST\"))","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Region-specific metrics can also be extracted. For example, to obtain the LOLE of Region A across the entire simulation period:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"eue_a = LOLE(shortfalls, \"Region A\")","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Finally, metrics can be obtained for both a specific region and time:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"period_eue_a = EUE(shortfalls, \"Region A\", ZonedDateTime(2024, 4, 27, 13, tz\"EST\"))","category":"page"},{"location":"quickstart/#Capacity-Credit-Calculations","page":"Quick Start","title":"Capacity Credit Calculations","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Capacity credit calculations build on probabilistic resource adequacy assessment to provide capacity-based quantifications of the marginal benefit to system resource adequacy associated with a specific resource or collection of resources. Two capacity credit metrics (EFC and ELCC) are currently supported.","category":"page"},{"location":"quickstart/#Equivalent-Firm-Capacity-(EFC)","page":"Quick Start","title":"Equivalent Firm Capacity (EFC)","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"EFC estimates the amount of idealized, 100%-available capacity that, when added to a baseline system, reproduces the level of system adequacy associated with the baseline system plus the study resource. The following parameters must be specified:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The risk metric to be used for comparison (i.e. EUE or LOLE)\nA known upper bound on the EFC value (usually the resource's nameplate capacity)\nThe regional distribution of the firm capacity to be added. This is typically chosen to match the regional distribution of the study resource's nameplate capacity.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"For example, to assess the EUE-based EFC of a new resource with 1000 MW nameplate capacity, added to the system in a single region named \"A\":","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"# The base system, with power units in MW\nbase_system\n\n# The base system augmented with some incremental resource of interest\naugmented_system\n\n# Get the lower and upper bounds on the EFC estimate for the resource\nefc = assess(\n    base_system, augmented_system, EFC{EUE}(1000, \"A\"),\n    SequentialMonteCarlo(samples=100_000))\nmin_efc, max_efc = extrema(efc)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"If the study resource were instead split between regions \"A\" (600MW) and \"B\" (400 MW), one could specify the firm capacity distribution as:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"efc = assess(\n    base_system, augmented_system, EFC{EUE}(1000, [\"A\"=>0.6, \"B\"=>0.4]),\n    SequentialMonteCarlo(samples=100_000))","category":"page"},{"location":"quickstart/#Equivalent-Load-Carrying-Capability-(ELCC)","page":"Quick Start","title":"Equivalent Load Carrying Capability (ELCC)","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"ELCC estimates the amount of additional load that can be added to the system (in every time period) in the presence of a new study resource, while maintaining the baseline system's original adequacy level. The following parameters must be specified:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The risk metric to be used for comparison (i.e. EUE or LOLE)\nA known upper bound on the ELCC value (usually the resource's nameplate capacity)\nThe regional distribution of the load to be added. Note that this choice is somewhat ambiguous in multi-region systems, so assumptions should be clearly specified when reporting analysis results.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"For example, to assess the EUE-based ELCC of a new resource with 1000 MW nameplate capacity, serving new load in region \"A\":","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"# The base system, with power units in MW\nbase_system\n\n# The base system augmented with some incremental resource of interest\naugmented_system\n\n# Get the lower and upper bounds on the ELCC estimate for the resource\nelcc = assess(\n    base_system, augmented_system, ELCC{EUE}(1000, \"A\"),\n    SequentialMonteCarlo(samples=100_000))\nmin_elcc, max_elcc = extrema(elcc)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"If instead the goal was to study the ability of the new resource to provide load evenly to regions \"A\" and \"B\", one could use:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"elcc = assess(\n    base_system, augmented_system, ELCC{EUE}(1000, [\"A\"=>0.5, \"B\"=>0.5]),\n    SequentialMonteCarlo(samples=100_000))","category":"page"},{"location":"quickstart/#Capacity-credit-calculations-in-the-presence-of-sampling-error","page":"Quick Start","title":"Capacity credit calculations in the presence of sampling error","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"For non-deterministic assessment methods (i.e. Monte Carlo simulations), running a resource adequacy assessment with different random number generation seeds will result in different risk metric estimates for the same underlying system. Capacity credit assessments can be sensitive to this uncertainty, particularly when attempting to study the impact of a small resource on a large system with a limited number of simulation samples. ","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"PRAS takes steps to a) limit this uncertainty and b) warn against potential deficiencies in statistical power resulting from this uncertainty.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"First, the same random seed is used across all simulations in the capacity credit assessment process. If the number of resources and their reliability parameters (MTTF and MTTR) remain constant across the baseline and augmented test systems, seed re-use ensures that unit-level outage profiles remain identical across RA assessments, providing a fixed background against which to measure changes in RA resulting from the addition of the study resource. Note that satisfying this condition requires that the study resource be present in the baseline case, but with its contributions eliminated (e.g. by setting its capacity to zero). When implementing an assessment method that modifies the user-provided system to add new resources (such as EFC), the programmer should assume this invariance exists in the provided data, and not violate it in any automated modifications.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Second, capacity credit assessments have two different stopping criteria. The ideal case is that the upper and lower bounds on the capacity credit metric converge to be sufficiently tight relative to a desired level of precision. This target precision is 1 system power unit (e.g. MW) by default, but can be relaxed to loosen the convergence bounds if desired via the capacity_gap keyword argument. Once the lower and upper bounds are tighter than this gap, their values are returned.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"Additionally, at each bisection step, a hypothesis test is performed to ensure that the theoretically-larger bounding risk metric is in fact larger than the smaller-valued risk metric with a specified level of statistical significance. By default, this criteria is a maximum p-value of 0.05, although this value can be changed as desired via the p_value keyword argument. If at some point the null hypothesis (the higher risk is not in fact larger than the lower risk) cannot be rejected at the desired significance level, the assessment will provide a warning indicating the size of the remaining capacity gap and return the lower and upper bounds on the capacity credit estimate.","category":"page"},{"location":"PRASCore/#PRAS-Core","page":"PRAS Core","title":"PRAS Core","text":"","category":"section"},{"location":"#PRAS","page":"Home","title":"PRAS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Announcement\nPRAS v0.8.0 was released in October 2025, and it includes the capability to  model shift and shed type demand reponse devices. If you need these  capabilities, be sure to increment PRAS version in your projects. There are no breaking changes with this release, and your old workflows will also work  as is.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Probabilistic Resource Adequacy Suite (PRAS) provides an open-source, research-oriented collection of tools for analysing the resource adequacy of a bulk power system.  It allows the user to simulate power system operations under a wide range of operating conditions in order to study the risk of failing to meet demand (due to a lack of supply or deliverability), and identify the time periods and regions in which that risk occurs. It offers high-performance sequential Monte Carlo methods supporting multi-region composite reliability assessment, including simulation of energy-limited resources such as storage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PRAS is developed and maintained at the US National Renewable Energy Laboratory (NREL).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started on using PRAS, see the installation and quick start pages.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PRAS maps a provided representation of a power system to a probabilistic description of operational outcomes of interest, using a particular choice of operations simulation. The input system representation is called a \"system model\", the choice of operational representation is referred to as a \"simulation specification\", and different types of operating outcomes of interest are described by \"result specifications\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"<figure>\n<img src=\"images/inputoutput.svg\" alt=\"PRAS model structure and corresponding assessment function arguments\" style=\"max-width:2000px;  width:100%;\"/>\n<figcaption> PRAS model structure and corresponding assessment function arguments </figcaption>\n</figure>","category":"page"},{"location":"","page":"Home","title":"Home","text":"PRAS is written in the Julia programming language, and is controlled through the use of Julia scripts. The three components of a PRAS resource adequacy assessment (a system model, a simulation specification, and result specifications) map directly to the Julia function arguments required to launch a PRAS run. A typical resource adequacy assessment with PRAS involves creating or loading a system model, then invoking PRAS' assess function to perform the analysis: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PRAS\n\nsys = SystemModel(\"filepath/to/mysystem.pras\")\n\nshortfallresult, flowresult =\n    assess(sys, SequentialMonteCarlo(), Shortfall(), Flow())\n\neue, lole = EUE(shortfallresult), LOLE(shortfallresult)","category":"page"},{"location":"PRASFiles/#PRAS-Files","page":"PRAS Files","title":"PRAS Files","text":"","category":"section"},{"location":"PRASFiles/","page":"PRAS Files","title":"PRAS Files","text":"PRASFiles.jl provides functionality for reading and writing PRAS-specific file formats, allowing you to save and load resource adequacy data structures.","category":"page"},{"location":"PRASFiles/","page":"PRAS Files","title":"PRAS Files","text":"This package enables:","category":"page"},{"location":"PRASFiles/","page":"PRAS Files","title":"PRAS Files","text":"Loading and saving PRAS system models\nImporting data from various formats\nExporting results and system information to standard formats","category":"page"},{"location":"PRASFiles/","page":"PRAS Files","title":"PRAS Files","text":"For detailed information on available methods and types, see the API Reference.","category":"page"}]
}
