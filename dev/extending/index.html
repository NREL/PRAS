<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending PRAS · PRAS</title><meta name="title" content="Extending PRAS · PRAS"/><meta property="og:title" content="Extending PRAS · PRAS"/><meta property="twitter:title" content="Extending PRAS · PRAS"/><meta name="description" content="Documentation for PRAS."/><meta property="og:description" content="Documentation for PRAS."/><meta property="twitter:description" content="Documentation for PRAS."/><meta property="og:url" content="https://nrel.github.io/PRAS/stable/extending/"/><meta property="twitter:url" content="https://nrel.github.io/PRAS/stable/extending/"/><link rel="canonical" href="https://nrel.github.io/PRAS/stable/extending/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PRAS</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../resourceadequacy/">Resource Adequacy</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li></ul></li><li><span class="tocitem">PRAS Components </span><ul><li><a class="tocitem" href="../PRAS/sysmodelspec/">System Model Specification</a></li><li><a class="tocitem" href="../PRAS/simulations/">Simulation Specifications</a></li><li><a class="tocitem" href="../PRAS/results/">Result Specifications</a></li><li><a class="tocitem" href="../PRAS/capacitycredit/">Capacity Credit Calculation</a></li></ul></li><li><a class="tocitem" href="../SystemModel_HDF5_spec/">.pras File Format</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../examples/pras_walkthrough/">PRAS 101 Walkthrough</a></li><li><a class="tocitem" href="../examples/demand_response_walkthrough/">Demand Response Walkthrough</a></li></ul></li><li class="is-active"><a class="tocitem" href>Extending PRAS</a><ul class="internal"><li><a class="tocitem" href="#customsimspec"><span>Custom Simulation Specifications</span></a></li><li><a class="tocitem" href="#Custom-Result-Specifications"><span>Custom Result Specifications</span></a></li><li><a class="tocitem" href="#Simulation-Result-Interfaces"><span>Simulation-Result Interfaces</span></a></li></ul></li><li><a class="tocitem" href="../changelog/">Changelog</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../PRASCore/api/">PRASCore</a></li><li><a class="tocitem" href="../PRASFiles/api/">PRASFiles</a></li><li><a class="tocitem" href="../PRASCapacityCredits/api/">PRASCapacityCredits</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Extending PRAS</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Extending PRAS</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL/PRAS" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL/PRAS/blob/main/docs/src/extending.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="extending"><a class="docs-heading-anchor" href="#extending">Extending PRAS</a><a id="extending-1"></a><a class="docs-heading-anchor-permalink" href="#extending" title="Permalink"></a></h1><p>PRAS provides opportunties for users to non-invasively build on its general simulation framework by redefining how simulations are executed, augmenting how results are reported, or both. This allows for customized analyses without requiring the user to modify code in the main PRAS package or implement their own model from scratch.</p><p>To implement custom functionality, a user needs to define specific Julia data structures as well as implement function methods that operate on those structures. Julia&#39;s multiple dispatch functionality can then identify and use these newly defined capabilities when the <code>assess</code> function is invoked appropriately.</p><h2 id="customsimspec"><a class="docs-heading-anchor" href="#customsimspec">Custom Simulation Specifications</a><a id="customsimspec-1"></a><a class="docs-heading-anchor-permalink" href="#customsimspec" title="Permalink"></a></h2><p>Custom simulation specifications allow for redefining how PRAS models system operations. In addition to the data structures and methods listed here, defining a new simulation specification also requires defining the appropriate simulation-result interactions (see <a href="#simulation-result-interfaces">Simulation-Result Interfaces</a>).</p><h3 id="New-Data-Structure-Requirements"><a class="docs-heading-anchor" href="#New-Data-Structure-Requirements">New Data Structure Requirements</a><a id="New-Data-Structure-Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#New-Data-Structure-Requirements" title="Permalink"></a></h3><p>The following new data structure (struct / type) should be defined in Julia:</p><h4 id="Simulation-Specification"><a class="docs-heading-anchor" href="#Simulation-Specification">Simulation Specification</a><a id="Simulation-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Specification" title="Permalink"></a></h4><p>The main type representing the new simulation specification. It should be a subtype of the <code>SimulationSpec</code> abstract type and can contain fields that store simulation parameters (such as the number of Monte Carlo samples to run or the random number generation seed to use). For example:</p><pre><code class="language-julia hljs">struct MyCustomSimSpec &lt;: SimulationSpec
    nsamples::UInt64
    seed::UInt64
end</code></pre><h3 id="New-Method-Requirements"><a class="docs-heading-anchor" href="#New-Method-Requirements">New Method Requirements</a><a id="New-Method-Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#New-Method-Requirements" title="Permalink"></a></h3><p>The following new function method should be defined in Julia:</p><h4 id="assess"><a class="docs-heading-anchor" href="#assess">assess</a><a id="assess-1"></a><a class="docs-heading-anchor-permalink" href="#assess" title="Permalink"></a></h4><p>The method to be invoked when the <code>assess</code> function is called with the previously defined simulation specification. By convention, the method should take a <code>SystemModel</code> as the first argument, followed by a specific subtype of <code>SimulationSpec</code>, followed by one or more unspecified subtypes of <code>ResultSpec</code>. For example (using the <code>MyCustomSimSpec</code> type defined above):</p><pre><code class="language-julia hljs">function PRAS.assess(
    sys::SystemModel, simspec::MyCustomSimSpec, resultspecs::ResultSpec...)

    # Implement the simulation logic for MyCustomSimSpec here

    # This will include simulation-result interaction calls to result
    # recording methods, which will need to be implemented by any result 
    # specification wanting to be compatible with MyCustomSimSpec

end</code></pre><h2 id="Custom-Result-Specifications"><a class="docs-heading-anchor" href="#Custom-Result-Specifications">Custom Result Specifications</a><a id="Custom-Result-Specifications-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Result-Specifications" title="Permalink"></a></h2><p>Custom result specifications allow for saving out additional information that may be generated during simulations of system operations. In addition to the data structures and methods listed here, defining a new result specification also requires defining the appropriate simulation-result interactions (see <a href="#simulation-result-interfaces">Simulation-Result Interfaces</a>).</p><h3 id="New-Data-Structure-Requirements-2"><a class="docs-heading-anchor" href="#New-Data-Structure-Requirements-2">New Data Structure Requirements</a><a class="docs-heading-anchor-permalink" href="#New-Data-Structure-Requirements-2" title="Permalink"></a></h3><p>The following new data structures (structs / types) should be defined in Julia:</p><h4 id="Result-Specification"><a class="docs-heading-anchor" href="#Result-Specification">Result Specification</a><a id="Result-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Result-Specification" title="Permalink"></a></h4><p>The main type representing the result specification. It should be a subtype of the <code>ResultSpec</code> abstract type and can contain fields that store result parameters (although this is usually not necessary). For example:</p><pre><code class="language-julia hljs">struct MyCustomResultSpec &lt;: ResultSpec
end</code></pre><h4 id="Result"><a class="docs-heading-anchor" href="#Result">Result</a><a id="Result-1"></a><a class="docs-heading-anchor-permalink" href="#Result" title="Permalink"></a></h4><p>The type of the data that is returned at the end of an assessment and stores any information to be reported to the end-user. It should be a subtype of the <code>Result</code> abstract type and should contain fields that store the desired results. For example:</p><pre><code class="language-julia hljs">struct MyCustomResult &lt;: Result
    myoutput1::Float64
    myoutput2::Vector{Bool}
end</code></pre><h3 id="New-Method-Requirements-2"><a class="docs-heading-anchor" href="#New-Method-Requirements-2">New Method Requirements</a><a class="docs-heading-anchor-permalink" href="#New-Method-Requirements-2" title="Permalink"></a></h3><h4 id="Indexing"><a class="docs-heading-anchor" href="#Indexing">Indexing</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></h4><p>Result data should support index lookups to report overall results or values for specific time periods, regions, interfaces, units, etc. The specifics of how the result data is indexed will depend on the nature of the result type, but will likely involve implementing one of more of the following methods (here we assume the new result type is <code>MyCustomResult</code>):</p><pre><code class="language-julia hljs">Base.getindex(result::MyCustomResult)
Base.getindex(result::MyCustomResult, region_or_unit::String)
Base.getindex(result::MyCustomResult, interface::Pair{String,String})
Base.getindex(result::MyCustomResult, period::ZonedDateTime)
Base.getindex(result::MyCustomResult,
              region_or_unit::String, period::ZonedDateTime)
Base.getindex(result::MyCustomResult,
              interface::Pair{String,String}, period::ZonedDateTime)</code></pre><h4 id="Risk-Metrics"><a class="docs-heading-anchor" href="#Risk-Metrics">Risk Metrics</a><a id="Risk-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Risk-Metrics" title="Permalink"></a></h4><p>If the result includes information that can be used to calculate resource adequacy metrics, some or all of following new function methods should be defined (here we assume the new result type is <code>MyCustomResult</code>):</p><pre><code class="language-julia hljs">PRAS.LOLE(result::MyCustomResult)
PRAS.LOLE(result::MyCustomResult, region::String)
PRAS.LOLE(result::MyCustomResult, period::ZonedDateTime)
PRAS.LOLE(result::MyCustomResult, region::String, period::ZonedDateTime)

PRAS.EUE(result::MyCustomResult)
PRAS.EUE(result::MyCustomResult, region::String)
PRAS.EUE(result::MyCustomResult, period::ZonedDateTime)
PRAS.EUE(result::MyCustomResult, region::String, period::ZonedDateTime)</code></pre><p>If desired, new result specifications may define additional result-specific accessor methods as well.</p><h2 id="Simulation-Result-Interfaces"><a class="docs-heading-anchor" href="#Simulation-Result-Interfaces">Simulation-Result Interfaces</a><a id="Simulation-Result-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Result-Interfaces" title="Permalink"></a></h2><p>Result specifications need a way to map information produced by a simulation to outcomes of interest. The specifics of how this is implemented will vary between simulation specifications, but in general, a specific <code>assess</code> method will invoke another method that records abstract results. This recording method will then be implemented by all of the concrete result specifications wishing to support that simulation specification. A very simplified example of this pattern is:</p><pre><code class="language-julia hljs">function assess(
    sys::SystemModel, simspec::MyCustomSimSpec, resultspecs::ResultSpec...)

    # Implement the simulation logic for MyCustomSimSpec here,
    # and collect full results
    simulationdata = ...

    # Store requested results
    results = ()
    for resultspec in resultspecs
        results = (results..., record(simspec, resultspec, simulationdata))
    end

    return results

end

function record(
    simspec::MyCustomSimSpec, resultspec::Shortfall, simulationdata)
    # Map simulationdata to shortfall results here
    return ShortfallResult(...)
end

function record(
    simspec::MyCustomSimSpec, resultspec::Surplus, simulationdata)
    # Map simulationdata to surplus results here
    return SurplusResult(...)
end

function record(
    simspec::MyCustomSimSpec, resultspec::MyCustomResultSpec, simulationdata)
    # Map simulationdata to my custom results here
    return MyCustomResult(...)
end</code></pre><p>By implementing the types and methods described here, a new result specification can be made compatible with these existing simulation types. In each case, we assume the <code>MyResultSpec &lt;: ResultSpec</code> and <code>MyResult &lt;: Result</code> types have been previously defined.</p><h3 id="Result-Accumulator"><a class="docs-heading-anchor" href="#Result-Accumulator">Result Accumulator</a><a id="Result-Accumulator-1"></a><a class="docs-heading-anchor-permalink" href="#Result-Accumulator" title="Permalink"></a></h3><p>A sequential Monte Carlo result accumulator incrementally collects relevant intermediate outcomes as chronological simulations under different random samples are performed.</p><pre><code class="language-julia hljs"># Define the accumulator structure
struct SMCMyResultAccumulator &lt;: ResultAccumulator{SequentialMonteCarlo,MyResultSpec}
    # fields for holding intermediate data go here
end

# Help PRAS know which accumulator type to expect before one&#39;s created
PRAS.ResourceAdequacy.accumulatortype(::SequentialMonteCarlo, ::MyResultSpec) =
    SMCMyResultAccumulator

# Initialize a new accumulator
function PRAS.ResourceAdequacy.accumulator(
    sys::SystemModel, simspec::SequentialMonteCarlo, resultspec::MyResultSpec)
    return SMCMyResultAccumulator(...)
end</code></pre><h4 id="record!"><a class="docs-heading-anchor" href="#record!">record!</a><a id="record!-1"></a><a class="docs-heading-anchor-permalink" href="#record!" title="Permalink"></a></h4><p>Once system operations in a given time period <code>t</code> have been simulated within a given chronological sample sequence <code>s</code>, the <code>record!</code> method extracts outcomes of interest from one or both of the system&#39;s current <code>state</code> and the solution to the period&#39;s dispatch problem <code>prob</code>. These results are used to update the accumulator <code>acc</code> in-place.</p><pre><code class="language-julia hljs">PRAS.ResourceAdequacy.record!(
    acc::SMCMyResultAccumulator, sys::SystemModel, state::SystemState,
    prob::DispatchProblem, s::Int, t::Int)</code></pre><h4 id="reset!"><a class="docs-heading-anchor" href="#reset!">reset!</a><a id="reset!-1"></a><a class="docs-heading-anchor-permalink" href="#reset!" title="Permalink"></a></h4><p>At the end of each chronological sequence of time periods <code>s</code>, the <code>reset!</code> method updates the accumulator <code>acc</code> in-place to finalize recording of any results requiring information from multiple periods, and prepare the accumulator to start receiving values from a new chronological simulation sequence.</p><pre><code class="language-julia hljs">PRAS.ResourceAdequacy.reset!(acc::SMCMyResultAccumulator, s::Int)

# Often no action is required here,
# so a simple one-line implementation is possible
PRAS.ResourceAdequacy.reset!(acc::SMCMyResultAccumulator, s::Int) = nothing</code></pre><h4 id="merge!"><a class="docs-heading-anchor" href="#merge!">merge!</a><a id="merge!-1"></a><a class="docs-heading-anchor-permalink" href="#merge!" title="Permalink"></a></h4><p>For multithreaded assessments PRAS creates one accumulator per worker thread (parallel task) and merges each thread&#39;s accumulator information togther once work is completed. <code>merge!</code> defines how an accumulator <code>a</code> should be updated in-place to incorporate the results obtained by another accumulator <code>b</code>.</p><pre><code class="language-julia hljs">PRAS.ResourceAdequacy.merge!(
    a::SMCMyResultAccumulator, b::SMCMyResultAccumulator)</code></pre><h4 id="finalize!"><a class="docs-heading-anchor" href="#finalize!">finalize!</a><a id="finalize!-1"></a><a class="docs-heading-anchor-permalink" href="#finalize!" title="Permalink"></a></h4><p>Once all of the thread accumulators have been merged down to a single accumulator reflecting results from all of the threads, this final accumulator <code>acc</code> is mapped to the final result output through a <code>finalize</code> method.</p><pre><code class="language-julia hljs">function PRAS.ResourceAdequacy.finalize(
    acc::SMCMyResultAccumulator, sys::SystemModel)

    return MyResult(...)

end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/demand_response_walkthrough/">« Demand Response Walkthrough</a><a class="docs-footer-nextpage" href="../changelog/">Changelog »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Tuesday 4 November 2025 17:55">Tuesday 4 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
